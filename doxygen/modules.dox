/*! @defgroup qclean QClean

@brief
White space cleanup utility

@description
QClean is a simple and blazingly fast command-line utility to automatically clean whitespace in your source code. QClean is a natively compiled executable, available in portable source code.  It can be compiled on all desktop platforms.
*/

/*###########################################################################*/
/*! @defgroup qfsgen QFSgen

@brief
ROM file system generator

@description
QFSGen is a cross-platform, command-line utility that generates a ROM-based file system, which can be incorporated in a C source. The QFSGen utility generates a C header file that contains multiple constant byte arrays representing your files and directories. This generated header file can be subsequently included in a ROM-Based File System implementation.

*/
/*###########################################################################*/
/*! @defgroup qpspy QP/Spy

@brief
Software tracing and testing system

@description
QP/Spy&trade; is a software tracing and testing system specifically designed for embedded systems, such as single chip microcontrollers. The job of QP/Spy is to capture information about an embedded code's execution and send it to the host computer with minimal impact on the real-time performance of the embedded code.
*/

/*###########################################################################*/
/*! @defgroup qs QS

@brief
QS software tracing system

@description
QS is a software tracing system that enables developers to monitor live event-driven QP applications with minimal target system resources and without stopping or significantly slowing down the code. QS is an ideal tool for testing, troubleshooting, and optimizing QP applications. QS can even be used to support acceptance testing in product manufacturing.
*/

/*###########################################################################*/
/*! @defgroup qutest QUTest

@brief
Unit Testing Harness (Framework)

@description
QUTest&trade; (pronounced 'cutest') is a unit testing harness (a.k.a. unit testing framework), which is specifically designed for deeply embedded systems, but also supports unit testing of embedded code on host computers ("dual targeting"). QUTest is the fundamental tooling for Test-Driven Development (TDD) of QP/C/C++ applications, which is a highly recommended best-practice.
*/

/*###########################################################################*/
/*! @defgroup qV QV

@brief
Simple cooperative ("Vanilla") kernel

@description
QV is a simple **cooperative** kernel (previously called "Vanilla" kernel). This kernel executes active objects one at a time, with priority-based scheduling performed before processing of each event. Due to naturally short duration of event processing in state machines, the simple QV kernel is often adequate for many real-time systems.

@section qv_overview QV Overview
The QV scheduler is engaged after every RTC step of any active object to choose the next active object to execute. The QV scheduler always chooses the highest-priority active object that has any events in its event queue. The QV scheduler then extracts the next event from this queue and dispatches it to the state machine associated with the active object. The state machine runs to completion, after which the QV scheduler runs and the cycle repeats.

Please note that because the state machines always return to the QV scheduler after each RTC step, a single stack can be used to process all state machines (memory-friendly architecture).

The QV scheduler can also very easily detect when all event queues are empty, at which point it can call the idle callback to let the application put the CPU and peripherals to a low-power sleep mode (power-friendly architecture).

Given the simplicity, portability, and low-resource consumption, the QV scheduler is very attractive. It allows you to partition the problem into active objects and execute these active objects in an orderly manner. The task-level response of this scheduler is the longest RTC step in the whole system, but because event-driven active objects don’t block, the RTC steps tend to be very short (typically just a few microseconds). Also, often you can break up longer RTC steps into shorter pieces, by posting an event to self and returning (“Reminder” state pattern). The self-posted event then triggers the continuation of longer processing.

*/
/*###########################################################################*/
/*! @defgroup qwin QWin GUI System

@brief
Free software toolkit for prototyping (dual-targeting) embedded systems on Windows in C

@description
QF is a portable, event-driven, real-time framework for execution of active objects (concurrent state machines) specifically designed for real-time embedded (RTE) systems.
*/

/*###########################################################################*/
