/*! @page qspy QSPY Host Application

@tableofcontents
@nav{qs,qspy_text}

@section qspy_about About QSPY
<p>As described in the @ref qpspy "previous section", **QSPY** is the host-resident component in the QP/Spy software tracing system. QSPY is a simple console application without a GUI, because its main purpose is to provide @ref qspy_link "communication" with the @ref qs "QS target-resident component", parsing of the @ref qpspy_proto "QP/Spy Data Protocol" and displaying the data in a simple @ref qspy_text "human-readable format".
</p>

![QSPY host application](qspy.png)


QSPY can also export the data in various other formats, such as format suitable for @ref qspy_matlab "MATLAB/GNU-Octave", and format suitable for generating @ref qspy_seq "sequence diagrams". Additionally, QSPY can also save the symbolic information about the Target objects in form of @ref qspy_dict "QSPY dictionaries". An example of a @ref qpspy_exa "QSPY session" is shown in the Introduction to QP/Spy.

Finally, QSPY supports also extensible @ref qspy_udp "UDP-socket" connection, which allows it to serve as a <em>"Back-End"</em> for attaching various "Front-Ends" (such as the @ref qutest "QUTest" Front-End and @ref qview "QView" Front-End).

@remark
QSPY is written in portable C with ports to Windows and POSIX (Linux, macOS) provided. QSPY is also designed to be adaptable to various target-host communication links. Out of the box, the QSPY host application supports serial (RS232), TCP/IP, and file communication links. Adding other communication links is straightforward, because the data link is accessed only through a generic Platform Abstraction Layer (PAL).


@section qspy_command QSPY Command-Line Parameters
<p>The QSPY application accepts several command-line parameters to configure the data link to the Target, backwards-compatibly with previous versions, and target dependencies, such as pointer sizes, signal sizes, etc. This means that the single QSPY host application can process data from any Target running the QS component. QSPY has been tested with wide range of 8-, 16-, 32-, and 64-bit CPUs.
</p>

The general form of invoking QSPY is as follows:

@verbatim
qspy [options]
@endverbatim

where `options` are described in the following table:

@verbatim
Usage: qspy [options]     <arg> = required, [arg] = optional
@endverbatim


<table>
  <tr>
    <th style="width:10%">Option</th>
    <th style="width:10%">Example</th>
    <th style="width:10%">Default (key)</th>
    <th style="width:20%">Must match<br>QP macro</th>
    <th style="width:50%">Comments</th>
  </tr>

  <tr>
    <td>-h</td>
    <td>-h</td>
    <td>(key-h)</td>
    <td></td>
    <td>Help. Prints the summary of options</td>
  </tr>

  <tr>
    <td>-q [num]</td>
    <td>-q 99</td>
    <td>(key-q)</td>
    <td></td>
    <td>Quiet mode (reduced stdout output)</td>
  </tr>

  <tr>
    <td>-u [UDP_port|0]</td>
    <td>-u</td>
    <td>7701</td>
    <td></td>
    <td>UDP socket for "Front-Ends".<br>`-u0` suppresses opening the UPD socket </td>
  </tr>

  <tr>
    <td>-v &lt;QS_version&gt;</td>
    <td>-v 6.2</td>
    <td>6.6</td>
    <td></td>
    <td>Enforce backwards-compatibility with the specific QS version</td>
  </tr>

  <tr>
    <td>-r &lt;c0|c1|c2&gt;</td>
    <td>-r c2</td>
    <td>c1</td>
    <td></td>
    <td>Rendering options (c0=no-color|c1-color1|c2-color2)</td>
  </tr>

  <tr>
    <td>-k</td>
    <td>-k</td>
    <td></td>
    <td></td>
    <td>suppress keyboard input</td>
  </tr>

  <tr>
    <td>-o</td>
    <td>-o</td>
    <td>(key-o)</td>
    <td></td>
    <td>Produce output to the specified file</td>
  </tr>

  <tr>
    <td>-s</td>
    <td>-s</td>
    <td>(key-s)</td>
    <td></td>
    <td>Save the binary input to a file. Not compatible with `-f`
    </td>
  </tr>

  <tr>
    <td>-m</td>
    <td>-m</td>
    <td>(key-m)</td>
    <td></td>
    <td>Produce @ref qspy_matlab "MATLAB/GNU-Octave output" to a file</td>
  </tr>

  <tr>
    <td>-g [object-list]</td>
    <td>-g obj1,obj2</td>
    <td>(key-g)</td>
    <td></td>
    <td>Produce @ref qspy_seq "Sequence diagram output" to a file</td>
  </tr>

  <tr>
    <td>-t [TCP-port]</td>
    <td>-t </td>
    <td>6601</td>
    <td></td>
    <td>TCP/IP input selection. Not compatible with `-c`, `-b`, `-f`</td>
  </tr>

  <tr>
    <td>-c &lt;port&gt;</td>
    <td>-c COM2</td>
    <td>COM1</td>
    <td></td>
    <td>COM port selection. Not compatible with `-t`, `-p`, `-f`</td>
  </tr>

  <tr>
    <td>-b &lt;baud&gt;</td>
    <td>-b 38400</td>
    <td>115200</td>
    <td></td>
    <td>Baud rate selection. Not compatible with `-t`, `-p`, `-f`</td>
  </tr>

  <tr>
    <td>-f &lt;file&gt;</td>
    <td>-f qs.spy</td>
    <td></td>
    <td></td>
    <td>File input selection. Not compatible with `-c`, `-b`, `-t`, `-p`</td>
  </tr>

  <tr>
    <td>-d [file]</td>
    <td>-d my_app.dic</td>
    <td></td>
    <td></td>
    <td>Read @ref qspy_dict "dictionaries" from a file.</td>
  </tr>

  <tr>
    <TD colspan="5"><strong>Options for configuring Target object sizes:</strong>
The Target can **report** it's configuration to QSPY, which means that you don't need to provide any upper-case options (such as: `-T`, `-O`, `-F`, etc.).
    </td>
  </tr>

  <tr>
    <th>Option</th>
    <th>Example</th>
    <th>Default (key)</th>
    <th>Must match QP macro</th>
    <th>Comments</th>
  </tr>

  <tr>
    <td>-T &lt;size&gt;</td>
    <td>-T 2</td>
    <td>4</td>
    <td>`QS_TIME_SIZE`</td>
    <td>Time stamp size in bytes. Valid values: 1, 2, 4</td>
  </tr>

  <tr>
    <td>-O &lt;size&gt;</td>
    <td>-O 2</td>
    <td>4</td>
    <td>`QS_OBJ_PTR_SIZE`</td>
    <td>Object pointer size in bytes. Valid values: 1, 2, 4, 8</td>
  </tr>

  <tr>
    <td>-F &lt;size&gt;</td>
    <td>-F 2</td>
    <td>4</td>
    <td>`QS_FUN_PTR_SIZE`</td>
    <td>Function pointer size in bytes. Valid values: 1, 2, 4, 8</td>
  </tr>

  <tr>
    <td>-S &lt;size&gt;</td>
    <td>-S 1</td>
    <td>2</td>
    <td>`Q_SIGNAL_SIZE`</td>
    <td>Signal size in bytes. Valid values: 1, 2, 4</td>
  </tr>

  <tr>
    <td>-E &lt;size&gt;</td>
    <td>-E 1</td>
    <td>2</td>
    <td>`QF_EVENT_SIZ_SIZE`</td>
    <td>Event-size size in bytes (i.e., the size of variables that hold
        event size). Valid values: 1, 2, 4</td>
  </tr>

  <tr>
    <td>-Q &lt;size&gt;</td>
    <td>-Q 2</td>
    <td>1</td>
    <td>`QF_EQUEUE_CTR_SIZE`</td>
    <td>Queue counter size in bytes. Valid values 1, 2, 4</td>
  </tr>

  <tr>
    <td>-P &lt;size&gt;</td>
    <td>-P 4</td>
    <td>2</td>
    <td>`QF_MPOOL_CTR_SIZE`</td>
    <td>Pool counter size in bytes. Valid values: 1, 2, 4</td>
  </tr>

  <tr>
    <td>-B &lt;size&gt;</td>
    <td>-B 1</td>
    <td>2</td>
    <td>`QF_MPOOL_SIZ_SIZE`</td>
    <td>Block size size in bytes. (i.e., the size of variables that hold
        memory block size). Valid values 1, 2, 4</td>
  </tr>

  <tr>
    <td>-C &lt;size&gt;</td>
    <td>-C 4</td>
    <td>2</td>
    <td>`QF_TIMEEVT_CTR_SIZE`</td>
    <td>Time event counter size. Valid values: 1, 2, 4</td>
  </tr>
</table>


Your main concern when invoking QSPY is to match exactly the target system you
are using. The fourth column of the table above lists the configuration macros
used by the target system as well as the platform-specific QP header files
where those macros are defined. You need to use the corresponding QSPY
command-line option only when the QP macro differs from the default. The
default values assumed by QSPY are consistent with the defaults used in QP.

@note
When you do not match the QSPY host application with the QS target
component, the QSPY application will be unable to parse correctly the
mismatched trace records and will start generating the following errors:<br>
<br>
@verbatim
   ~ ~ ~
   <COMMS> ERROR    4 bytes unused in Rec=QS_QEP_INTERN_TRAN
   ~ ~ ~
   <COMMS> ERROR    2 bytes unused in Rec=QS_QEP_DISPATCH
@endverbatim
<br>
The name after `Rec=` indicates the <a href="qs__copy_8h.html#acdb495c1e5524b5d95aaff82c47f6db5"><strong>Record ID</strong></a> of the trace record that failed to be parsed.


@subsection qspy_default Default Configuration
The QSPY application invoked **without any parameters** defaults to the following configuration:

@verbatim
C:\tmp>qspy
QSPY 6.6.0 Copyright (c) 2005-2019 Quantum Leaps
Documentation: https://www.state-machine.com/qtools/qspy.html
Current timestamp: 190811_124028
-u 7701
-t 6601
-v 660
-T 4
-O 4
-F 4
-S 2
-E 2
-Q 1
-P 2
-B 2
-C 2
@endverbatim

Specifically, by default QSPY **opens the UDP socket** at the default port (`-u 7701`) for "back-ends" (such as @ref qutest "QUTest") and **opens the TCP/IP socket** at the default port (`-t 6601`) for communication with the Targets.


The other parameters correspond to 32-bit Target CPUs, such as ARM and x86 compiled in 32-bit mode. The x86 is relevant for running the embedded software on host machines based on the x86 processors.

@remark
The default QSPY configuration is specifically designed for running @ref qutest "QUTest" tests on the x86-based hosts with target executables compiled in the 32-bit x86 mode. This default configuration also matches 32-bit ARM CPUs, but typically requires the single `-c <COM>` parameter to communicate with the embedded Target via a serial port.@n
@n
The default QSPY configuration (without any parameters) is also backwards-compatible with the following invocation: `qspy -u -t`, which is recommended for running QUTest tests on the host computer. Starting with QSPY version 7.x.y, you can use the simpler `qspy` invocation.


@section qspy_terminating Terminating QSPY
The QSPY host application can be terminated in the following ways:

- by typing `x` or `X` key (works only in the absence of the __-k__ @ref qspy_command "command-line option")
- by typing `Esc` key (works only in the absence of the __-k__ @ref qspy_command "command-line option")
- by typing `Ctrl-C` (works also with the `-k` option)
- by sending the Kill signal to the process running QSPY


@section qspy_keyboard QSPY Keyboard Commands
In the __absence of the -k (suppress keyboard) command-line option__, the QSPY console application accepts keyboard input. The following table shows the currently supported key-strokes:


Key | Action
----|---------
`&lt;Esc&gt;` | Exit QSPY
`h`     | display keyboard help and QSPY status
`c`     | clear the screen
`q`     | toggle quite mode (no Target output to the screen)
`r`     | send RESET command to the Target
`i`     | send the INFO request to the Target (see also @ref qspy_dict)
`t`     | send TIKC[0] command to the Target
`u`     | send TICK[1] command to the Target
`d`     | save @ref qspy_dict "QP/Spy Dictionaries" to a file
`o`     | toggle @ref qspy_text "QSPY Human-Readable Output" to a file (open/close)
`s`/`b` | toggle binary file output (open/close)
`m`     | toggle @ref qspy_matlab "MATLAB Output" to a file (open/close)
`g`     | toggle @ref qspy_seq "Sequence Output" to a file (open/close)


@n
@note
QSPY can send many more sophisticated commands to the Target by means of the @ref qview "Front-End extension mechanism".


@section qspy_link QSPY Communication with the Target
QSPY currently provides the following communication links to the @ref qs "QS target-resident component":


Communication Link | Command-Line Option
:------------------|:--------------------
TCP/IP             | `-t [TCP_port]` (default)
Serial port        | `-c <COM_port>` and `-b<baud_rate>`
Binaly File        | `-f <file_name>`
Other link@n(e.g., JTAG debug probe) | can be added to the QSPY Platform Abstraction Layer


@section qspy_saving Saving Files from QSPY

QSPY can save the tracing data from the Target in various formats into files. QSPY assigns file names **automatically**. Also, QSPY can open/close various files multiple times in a single session, so it is no longer necessary to exit QSPY and launch it again with different command-line parameters to save data to a different file.

@attention
QSPY saves all files into the <strong>current directory</strong> from which `qspy` has been launched.

QSPY uses a very simple naming convention to assign file names. All names start with `qspy<time-stamp>`, where the  time-stamp format is: `YYMMDD_hhmmss`, where `YY` is 2-digit year, `MM` is a 2-digit month, `DD` is a 2-digit day of the month, `hh` is a 2-digit hour, `mm` is a 2-digit minute, and `ss` is a 2-digit second. The time-stamp is accurate to a one second, so its virtually impossible to have name conflicts for files generated on the same machine. The various types of files are distinguished by the following extensions:

Command-Line@n Option | Keyboard@n Option| File@n Extension |  Example |  Comment
:-------------------:|:-----------------:|:----------------:|----------|----------
`-o`                | `o`            | `.txt`    | `qspy150914_132234.txt`| @ref qspy_text "text (screen) output"
`-s`                | `s`            | `.qs`     | `qspy150914_132234.qs`  | @ref qpspy_proto "raw binary output"
`-d`                | `d`            | `.dic`    | `qspy150901_101203.dic` | @ref qspy_dict "dictionary output"
`-m`                | `m`            | `.mat`    | `qspy150914_132234.mat` | @ref qspy_matlab "MATLAB output"
`-g`                | `g`            | `.seq`    | `qspy150914_132234.seq` | @ref qspy_seq "Sequence diagram output"

@note
All files except the dictionary output are time-stamped with the <strong>local</strong> time of the Host. The **dictionary** output is time-stamped with the build-time of the Target image.



The following sub-sections explain the following QSPY features:

- @subpage qspy_text "text (screen) output"
- @subpage qspy_dict "dictionary output"
- @subpage qspy_udp  "UDP socket interface"
- @subpage qspy_seq  "Sequence diagram output"
- @subpage qspy_matlab "MATLAB output"

@nav{qs,qspy_text}
*/
/*###########################################################################*/
/**
@page qspy_text QSPY Screen Output

@tableofcontents
@nav{qspy,qspy_dict}

<p>QSPY provides a simple consolidated, human-readable textual output to the screen. The readability of this output depends strongly on the availability of the <em>symbolic information</em> about the various objects in the Target code, called @ref qspy_dict "dictionaries". If the "dictionaries" are not available, QSPY can output only the hexadecimal values of various object addresses and event signals. However, if QSPY has acquired the @ref qs_dict "dictionaries" from the Target, or has @ref qspy_dict "read them from a file", it can apply the symbolic information to output the provided identifiers for objects, signals, and states.
</p>

@note
In the process of adapting QSPY for supporting @ref qutest "QUTest Unit Testing", the QSPY human-redable output has been changed to avoid any special characters used in regular expressions, such as `*, [, ], ?, !`. This is because the QUTest scripts use regular expressions to match QSPY textuall output with the expected output.


@section qspy_text_exa Screen Output Example
For example, the following listing shows the QSPY text output when the @ref qs_dict "dictionaries" **are** available:

<div style="height:40em;overflow:auto;">
@verbatim
QSPY 6.9.0 Copyright (c) 2005-2020 Quantum Leaps
Documentation: https://www.state-machine.com/qtools/qspy.html
Current timestamp: 200827_093625
-c COM7
-u 7701
-v 660
-T 4
-O 4
-F 4
-S 2
-E 2
-Q 1
-P 2
-B 2
-C 2

########## Trg-RST  QP-Ver=690,Build=200824_123230
           Obj-Dict 0x20001048->QS_RX
           Obj-Dict 0x08004009->l_SysTick_Handler
           Usr-Dict 00000100->PHILO_STAT
           Obj-Dict 0x20000EE0->AO_Table
           Obj-Dict 0x20000DDC->AO_Philo[0]
           Obj-Dict 0x20000E10->AO_Philo[1]
           . . . . .
           Obj-Dict 0x20000F94->EvtPool1
           Obj-Dict 0x20000DDC->Philo_inst[0]
           Obj-Dict 0x20000E00->Philo_inst[0].timeEvt
           Obj-Dict 0x20000E10->Philo_inst[1]
           Obj-Dict 0x20000E34->Philo_inst[1].timeEvt
           Obj-Dict 0x20000E44->Philo_inst[2]
           . . . . .
           Fun-Dict 0x080006A9->Philo_initial
           Fun-Dict 0x08000915->Philo_thinking
           Fun-Dict 0x08000871->Philo_hungry
           Fun-Dict 0x080007C5->Philo_eating
           Sig-Dict 00000010,Obj=0x20000DDC->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000DDC->TIMEOUT_SIG
0000000000 AO-Subsc Obj=Philo_inst[0],Sig=00000004,Obj=0x20000DDC
0000000000 AO-Subsc Obj=Philo_inst[0],Sig=00000008,Obj=0x20000DDC
===RTC===> St-Init  Obj=Philo_inst[0],State=0x08001099->Philo_thinking
0000000000 TE0-Arm  Obj=Philo_inst[0].timeEvt,AO=Philo_inst[0],Tim=84,Int=0
===RTC===> St-Entry Obj=Philo_inst[0],State=Philo_thinking
0000000000 Init===> Obj=Philo_inst[0],State=Philo_thinking
           Sig-Dict 00000010,Obj=0x20000E10->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000E10->TIMEOUT_SIG
           . . . . .
           . . . . .
===RTC===> St-Init  Obj=Table_inst,State=0x08001099->Table_serving
===RTC===> St-Entry Obj=Table_inst,State=Table_serving
0000000000 Init===> Obj=Table_inst,State=Table_serving
           QF_RUN
4294946722 QF-Pub   Sdr=l_SysTick_Handler,Evt<Sig=SERVE_SIG,Pool=0,Ref=0>
4294947277 AO-Post  Sdr=l_SysTick_Handler,Obj=Table_inst,Evt<Sig=SERVE_SIG,Pool=0,Ref=0>,Que<Free=5,Min=5>
4294948158 Sch-Next Pri=0->6
4294948490 AO-GetL  Obj=Table_inst,Evt<Sig=SERVE_SIG,Pool=0,Ref=0>
4294949010 Disp===> Obj=Table_inst,Sig=SERVE_SIG,State=Table_serving
4294949660 =>Ignore Obj=Table_inst,Sig=SERVE_SIG,State=Table_serving
4294950254 Sch-Idle Pri=6->0
           TE0-ADis Obj=Philo_inst[4].timeEvt,AO=Philo_inst[4]
4294946907 TE0-Post Obj=Philo_inst[4].timeEvt,Sig=TIMEOUT_SIG,AO=Philo_inst[4]
4294947535 AO-Post  Sdr=l_SysTick_Handler,Obj=Philo_inst[4],Evt<Sig=TIMEOUT_SIG,Pool=0,Ref=0>,Que<Free=5,Min=5>
4294948568 Sch-Next Pri=0->5
4294948900 AO-GetL  Obj=Philo_inst[4],Evt<Sig=TIMEOUT_SIG,Pool=0,Ref=0>
4294949419 Disp===> Obj=Philo_inst[4],Sig=TIMEOUT_SIG,State=Philo_thinking
4294950135 TE0-DisA Obj=Philo_inst[4].timeEvt,AO=Philo_inst[4]
===RTC===> St-Exit  Obj=Philo_inst[4],State=Philo_thinking
4294951090 QF-New   Sig=HUNGRY_SIG,Size=6
4294951506 MP-Get   Obj=EvtPool1,Free=9,Min=9
4294952081 AO-Post  Sdr=Philo_inst[4],Obj=Table_inst,Evt<Sig=HUNGRY_SIG,Pool=1,Ref=1>,Que<Free=5,Min=5>
4294952841 Sch-Next Pri=5->6
4294953173 AO-GetL  Obj=Table_inst,Evt<Sig=HUNGRY_SIG,Pool=1,Ref=1>
4294953692 Disp===> Obj=Table_inst,Sig=HUNGRY_SIG,State=Table_serving
4294954299 PHILO_STAT 4 hungry
4294954817 QF-New   Sig=EAT_SIG,Size=6
4294955233 MP-Get   Obj=EvtPool1,Free=8,Min=8
4294955759 QF-Pub   Sdr=Table_inst,Evt<Sig=EAT_SIG,Pool=1,Ref=0>
4294956277 Sch-Lock Ceil=0->5
4294956667 AO-Post  Sdr=Table_inst,Obj=Philo_inst[4],Evt<Sig=EAT_SIG,Pool=1,Ref=2>,Que<Free=5,Min=5>
4294957464 AO-Post  Sdr=Table_inst,Obj=Philo_inst[3],Evt<Sig=EAT_SIG,Pool=1,Ref=3>,Que<Free=5,Min=5>
4294958261 AO-Post  Sdr=Table_inst,Obj=Philo_inst[2],Evt<Sig=EAT_SIG,Pool=1,Ref=4>,Que<Free=5,Min=5>
4294959058 AO-Post  Sdr=Table_inst,Obj=Philo_inst[1],Evt<Sig=EAT_SIG,Pool=1,Ref=5>,Que<Free=5,Min=5>
4294959855 AO-Post  Sdr=Table_inst,Obj=Philo_inst[0],Evt<Sig=EAT_SIG,Pool=1,Ref=6>,Que<Free=5,Min=5>
4294960624 Sch-Unlk Ceil=5->0
. . . . . .
@endverbatim
</div>

The QS trace log shown in the listing above contains quite detailed information, because most QS records are enabled (are not blocked in the @ref qs_filters "QS filters"). The following bullet items highlight the most interesting parts of the trace and illustrate how you can interpret the trace data:

- The QS output starts with the QSPY application version number, the date and time of the run (run time-stamp), and all the options explicitly provided to the QSPY host application.

- The first trace records in the log are typically @ref qspy_dict "dictionary trace records" that provide a mapping between addresses of various objects in memory and their symbolic names.

- After the dictionaries, you see the active object initialization. For example, the `===RTC===> St-Init` record indicates that the top-most initial transition in the active object `l_table` has been taken. After this, the `===RTC===> St-Entry` record informs you that the state `Table_serving` has been entered, and finally the record `==>Init` tells you that the top-most initial transition sequence has completed. This trace record has a high-resolution @ref qs_tstamp "time-stamp" (the first 10-digit number) generated by the Target. The time units used by this time-stamp depend on the specific hardware timer used in the Target, but typically it is sub-microsecond.

- After this you see that at the time-stamp `0000380805` an event was dispatched (`Disp===>` record) to `l_table`, but it was subsequently `Ignored`, while `l_table` was in the state `Table_serving`.


@section qspy_pre Predefined Trace Records
The following table summarizes the text output format used for all predefined QS trace records (see ::QSpyRecords).

@note
To better adapt QSPY to support @ref qutest "QUTest Unit Testing", the QSPY human-redable output has been changed at @ref qtools_5_9_0 "version 5.9.0" to avoid any special characters used in regular expressions, such as `*, [, ], ?, !`. This is because the QUTest scripts use regular expressions to match QSPY textuall output with the expected output.


<table>
  <tr>
      <TD colspan="4"><strong>State Machine Trace Records (QEP)</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>1</td>
    <td>#QS_QEP_STATE_ENTRY</td>
    <td>`===RTC===> St-Entry`</td>
    <td>a state was entered</td>
  </tr>

  <tr>
    <td>2</td>
    <td>#QS_QEP_STATE_EXIT</td>
    <td>`===RTC===> St-Exit`</td>
    <td>a state was exited</td>
  </tr>

  <tr>
    <td>3</td>
    <td>#QS_QEP_STATE_INIT</td>
    <td>`<timestamp> St-Init`</td>
    <td>an initial transition was taken in a state</td>
  </tr>

  <tr>
    <td>4</td>
    <td>#QS_QEP_INIT_TRAN</td>
    <td>`<timestamp> Init===>`</td>
    <td>the top-most initial transition was taken</td>
  </tr>

  <tr>
    <td>5</td>
    <td>#QS_QEP_INTERN_TRAN</td>
    <td>`<timestamp> =>Intern`</td>
    <td>an internal transition was taken</td>
  </tr>

  <tr>
    <td>6</td>
    <td>#QS_QEP_TRAN</td>
    <td>`<timestamp> ===>Tran `</td>
    <td>a regular transition was taken</td>
  </tr>

  <tr>
    <td>7</td>
    <td>#QS_QEP_IGNORED</td>
    <td>`<timestamp> =>Ignore`</td>
    <td>an event was ignored (silently discarded)</td>
  </tr>

  <tr>
    <td>8</td>
    <td>#QS_QEP_DISPATCH</td>
    <td>`<timestamp> Disp===>`</td>
    <td>an event was dispatched (begin of RTC step)</td>
  </tr>

  <tr>
    <td>9</td>
    <td>#QS_QEP_UNHANDLED</td>
    <td>`===RTC===> St-Unhnd`</td>
    <td>a guard prevented handling of an event</td>
  </tr>

  <tr>
    <td>55</td>
    <td>#QS_QEP_TRAN_HIST</td>
    <td>`===RTC===> St-Hist`</td>
    <td>an a transition to history was taken </td>
  </tr>

  <tr>
    <td>56</td>
    <td>#QS_QEP_TRAN_EP</td>
    <td>`===RTC===> St-EP`</td>
    <td>an a transition to entry point into a submachine </td>
  </tr>

  <tr>
    <td>57</td>
    <td>#QS_QEP_TRAN_XP</td>
    <td>`===RTC===> St-XP`</td>
    <td>an a transition to exit  point out of a submachine </td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Active Object Trace Records</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>12</td>
    <td>#QS_QF_ACTIVE_SUBSCRIBE</td>
    <td>`<timestamp> AO-Subsc`</td>
    <td>an AO subscribed to an event</td>
  </tr>

  <tr>
    <td>13</td>
    <td>#QS_QF_ACTIVE_UNSUBSCRIBE</td>
    <td>`<timestamp> AO-Unsub`</td>
    <td>an AO unsubscribed to an event</td>
  </tr>

  <tr>
    <td>14</td>
    <td>#QS_QF_ACTIVE_POST</td>
    <td>`<timestamp> AO-Post`</td>
    <td>an event was posted (FIFO) directly to AO</td>
  </tr>

  <tr>
    <td>15</td>
    <td>#QS_QF_ACTIVE_POST_LIFO</td>
    <td>`<timestamp> AO-LIFO`</td>
    <td>an event was posted (LIFO) directly to AO</td>
  </tr>

  <tr>
    <td>16</td>
    <td>#QS_QF_ACTIVE_GET</td>
    <td>`<timestamp> AO-Get`</td>
    <td>AO got an event and its queue is still not empty</td>
  </tr>

  <tr>
    <td>17</td>
    <td>#QS_QF_ACTIVE_GET_LAST</td>
    <td>`<timestamp> AO-GetL`</td>
    <td>AO got an event and its queue is empty</td>
  </tr>

  <tr>
    <td>45</td>
    <td>#QS_QF_ACTIVE_POST_ATTEMPT</td>
    <td>`<timestamp> AO-PostA`</td>
    <td>attempt to post an evt to AO failed</td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Raw Event Queue Trace Records</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>19</td>
    <td>#QS_QF_EQUEUE_POST</td>
    <td>`<timestamp> EQ-Post`</td>
    <td>an event was posted (FIFO) to a raw queue</td>
  </tr>

  <tr>
    <td>20</td>
    <td>#QS_QF_EQUEUE_POST_LIFO</td>
    <td>`<timestamp> EQ-LIFO`</td>
    <td>an event was posted (LIFO) to a raw queue</td>
  </tr>

  <tr>
    <td>21</td>
    <td>#QS_QF_EQUEUE_GET</td>
    <td>`<timestamp> EQ-Get`</td>
    <td>get an event and queue still not empty</td>
  </tr>

  <tr>
    <td>22</td>
    <td>#QS_QF_EQUEUE_GET_LAST</td>
    <td>`<timestamp> EQ-GetL`</td>
    <td>get the last event from the queue</td>
  </tr>

  <tr>
    <td>46</td>
    <td>#QS_QF_EQUEUE_POST_ATTEMPT</td>
    <td>`<timestamp> EQ-PostA`</td>
    <td>attempt to post an evt to QEQueue failed</td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Raw Memory Pool Trace Records</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>24</td>
    <td>#QS_QF_MPOOL_GET</td>
    <td>`<timestamp> MP-Get`</td>
    <td>a memory block was removed from a memory pool</td>
  </tr>

  <tr>
    <td>24</td>
    <td>#QS_QF_MPOOL_GET_ATTEMPT</td>
    <td>`<timestamp> MP-GetA`</td>
    <td>a memory block was removed from a memory pool</td>
  </tr>

  <tr>
    <td>25</td>
    <td>#QS_QF_MPOOL_PUT</td>
    <td>`<timestamp> MP-Put`</td>
    <td>a memory block was returned to a memory pool</td>
  </tr>

  <tr>
    <td>47</td>
    <td>#QS_QF_MPOOL_GET_ATTEMPT</td>
    <td>`<timestamp> MP-GetA`</td>
    <td>attempt to get a memory block failed </td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Event Management (QF)</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>26</td>
    <td>#QS_QF_PUBLISH</td>
    <td>`<timestamp> QF-Pub`</td>
    <td>an event was published</td>
  </tr>

  <tr>
    <td>27</td>
    <td>RESERVED</td>
    <td></td>
    <td></td>
  </tr>

  <tr>
    <td>28</td>
    <td>#QS_QF_NEW</td>
    <td>`<timestamp> QF-New`</td>
    <td>new event creation</td>
  </tr>

  <tr>
    <td>29</td>
    <td>#QS_QF_GC_ATTEMPT</td>
    <td>`<timestamp> QF-gcA`</td>
    <td>garbage collection attempt</td>
  </tr>

  <tr>
    <td>30</td>
    <td>#QS_QF_GC</td>
    <td>`<timestamp> QF-gc`</td>
    <td>garbage collection performed</td>
  </tr>

  <tr>
    <td>31</td>
    <td>#QS_QF_TICK</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tick`</td>
    <td>QF system clock tick processing was called</td>
  </tr>

  <tr>
    <td>39</td>
    <td>#QS_QF_CRIT_ENTRY</td>
    <td>`<timestamp> QF-CritE`</td>
    <td>critical section was entered</td>
  </tr>

  <tr>
    <td>40</td>
    <td>#QS_QF_CRIT_EXIT</td>
    <td>`<timestamp> QF-CritX`</td>
    <td>critical section was exited</td>
  </tr>

  <tr>
    <td>41</td>
    <td>#QS_QF_ISR_ENTRY</td>
    <td>`<timestamp> QF-IsrE`</td>
    <td>an ISR was entered</td>
  </tr>

  <tr>
    <td>42</td>
    <td>#QS_QF_ISR_EXIT</td>
    <td>`<timestamp> QF-IsrX`</td>
    <td>an ISR was exited</td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Time Events (TE)</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>32</td>
    <td>#QS_QF_TIMEEVT_ARM</td>
    <td>`<timestamp> TE-Arm`</td>
    <td>a time event was armed</td>
  </tr>

  <tr>
    <td>33</td>
    <td>#QS_QF_TIMEEVT_AUTO_DISARM</td>
    <td>`<timestamp> TE-ADis`</td>
    <td>a time event expired and was disarmed</td>
  </tr>

  <tr>
    <td>34</td>
    <td>#QS_QF_TIMEEVT_DISARM_ATTEMPT</td>
    <td>`<timestamp> TE-DisA`</td>
    <td>attempt to disarmed a disarmed tevent</td>
  </tr>

  <tr>
    <td>35</td>
    <td>#QS_QF_TIMEEVT_DISARM</td>
    <td>`<timestamp> TE-Dis`</td>
    <td>true disarming of an armed time event</td>
  </tr>

  <tr>
    <td>36</td>
    <td>#QS_QF_TIMEEVT_REARM</td>
    <td>`<timestamp> TE-Rarm`</td>
    <td>rearming of a time event</td>
  </tr>

  <tr>
    <td>37</td>
    <td>#QS_QF_TIMEEVT_POST</td>
    <td>`<timestamp> TE-Post`</td>
    <td>a time event posted itself directly to an AO</td>
  </tr>

  <tr>
    <td>38</td>
    <td>#QS_QF_TIMEEVT_CTR</td>
    <td>`<timestamp> TE-Ctr`</td>
    <td>a time event counter was requested </td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Scheduler Trace Records</strong></td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>50</td>
    <td>#QS_SCHED_LOCK</td>
    <td>`<timestamp> Sch-Lock`</td>
    <td>scheduler was locked</td>
  </tr>

  <tr>
    <td>51</td>
    <td>#QS_SCHED_UNLOCK</td>
    <td>`<timestamp> Sch-Unlk`</td>
    <td>scheduler was unlocked</td>
  </tr>

  <tr>
    <td>52</td>
    <td>#QS_SCHED_NEXT</td>
    <td>`<timestamp> Sch-Next`</td>
    <td>scheduler found next task to execute</td>
  </tr>

  <tr>
    <td>53</td>
    <td>#QS_SCHED_IDLE</td>
    <td>`<timestamp> Sch-Idle`</td>
    <td>scheduler became idle</td>
  </tr>

  <tr>
    <td>54</td>
    <td>#QS_SCHED_RESUME</td>
    <td>`<timestamp> Sch-Rsme`</td>
    <td>scheduler resumed previous task (not idle)</td>
  </tr>

  <tr>
      <TD colspan="4"><strong>Miscellaneous Trace Records@n
      NOT MASKABLE WITH THE @ref qs_global "QS GLOBAL FILTER"!
      </strong>
      </td>
  </tr>

  <tr>
    <th>Rec.@n Num</th>
    <th>Rec.@n Enum</th>
    <th>Start of record</th>
    <th>Comment</th>
  </tr>

  <tr>
    <td>58</td>
    <td>#QS_TEST_PAUSED</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TstPause`</td>
    <td>test has been paused</td>
  </tr>

  <tr>
    <td>59</td>
    <td>#QS_TEST_PROBE_GET</td>
    <td>`<timestamp> TstProbe`</td>
    <td>reports that Test-Probe has been used</td>
  </tr>

  <tr>
    <td>60</td>
    <td>#QS_SIG_DICTIONARY</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sig-Dict`</td>
    <td>signal dictionary entry</td>
  </tr>

  <tr>
    <td>61</td>
    <td>#QS_OBJ_DICTIONARY</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Obj-Dict`</td>
    <td>object dictionary entry</td>
  </tr>

  <tr>
    <td>62</td>
    <td>#QS_FUN_DICTIONARY</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun-Dict`</td>
    <td>function dictionary entry</td>
  </tr>

  <tr>
    <td>63</td>
    <td>#QS_USR_DICTIONARY</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usr-Dict`</td>
    <td>User record dictionary entry</td>
  </tr>

  <tr>
    <td>64</td>
    <td>#QS_TARGET_INFO</td>
    <td>`########## Trg-Info`</td>
    <td>reports the Target information</td>
  </tr>

  <tr>
    <td>65</td>
    <td>#QS_TARGET_DONE</td>
    <td>`<timestamp> Trg-Done`</td>
    <td>reports completion of a user callback</td>
  </tr>

  <tr>
    <td>66</td>
    <td>#QS_RX_STATUS</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trg-Ack`</td>
    <td>reports QS data receive status</td>
  </tr>

  <tr>
    <td>66</td>
    <td>RESERVED</td>
    <td></td>
    <td></td>
  </tr>

  <tr>
    <td>66</td>
    <td>#QS_PEEK_DATA</td>
    <td>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trg-Peek`</td>
    <td>reports the data from the PEEK query</td>
  </tr>

  <tr>
    <td>67</td>
    <td>#QS_ASSERT_FAIL</td>
    <td>`<timestamp> =ASSERT=`</td>
    <td>Assertion fired</td>
  </tr>

  <tr>
      <TD colspan="4"><strong>User (Application Specific) Records</strong></td>
  </tr>

  <tr>
    <td>100</td>
    <td>#QS_USER + xxx</td>
    <td>`<timestamp> USER+xxx`</td>
    <td>@ref qs_app "application-specific" (user) QS records (100..124)</td>
  </tr>
</table>

@nav{qspy,qspy_dict}
*/
/*###########################################################################*/
/**
@page qspy_dict QSPY Dictionaries

@tableofcontents
@nav{qspy_text,qspy_udp}

@section qspy_dict_about About QSPY Dictionaries
By the time you compile and load your application image to the Target, the symbolic names of various objects, function names, and event signal names are stripped from the code. Therefore, if you want to have the symbolic information available to the QSPY host-resident component, you need to supply it somehow to the software tracing system.

The QS Target-resident component provides special @ref qs_dict "dictionary trace records" designed expressly for providing the symbolic information about the target code in the trace itself. These "dictionary records" are very much like the symbolic information embedded in the object files for the traditional single-step debugger. QS can supply four types of dictionary trace records:

- object dictionary -- for identifying objects (HSMs, AOs, Time events, etc)
- function dictionary -- for identifying functions (state-handlers)
- signal dictionary -- for identifying event signals
- user dictionary -- for identifying @ref qs_app "application-specific" (user) records

@note
QSPY does not absolutely require the presence of dictionary trace records to generate the human-readable output, in the same way as the symbolic information in the object files is not absolutely required to debug code. However, in both cases, the availability of the symbolic information greatly improves the readability of the disassembly code shown in the debugger.


For instance, the following listing shows an example of the QSPY text output when the "dictionaries" are **not** available. (<b>NOTE:</b> dictionaries might not be available because (1) the Target does not produce @ref qs_dict "dictionary trace records" for all relevant objects or (2) the Target does produce all dictionaries, but QSPY has never seen them, because it was attached to the Target after the dictionaries have been transmitted):
@n
@verbatim
. . . . . .
0009692721 Disp===> Obj=0x2000133C,Sig=00000010,Obj=0x2000133C,State=0x000010C5
0009693389 USER+000 4 hungry
0009695383 USER+000 4 eating
0009695932 =>Intern Obj=0x2000133C,Sig=00000010,Obj=0x2000133C,State=0x000010C5
===RTC===> St-Entry Obj=0x200012F8,State=0x00000D49
0009697188 ===>Tran Obj=0x200012F8,Sig=00000011,Obj=0x200012F8,State=0x00000DD5->0x00000D49
0009698052 Disp===> Obj=0x200012F8,Sig=00000004,Obj=0x200012F8,State=0x00000D49
===RTC===> St-Entry Obj=0x200012F8,State=0x00000CA9
0009699697 ===>Tran Obj=0x200012F8,Sig=00000004,Obj=0x200012F8,State=0x00000D49->0x00000CA9
0009700602 Disp===> Obj=0x200012B8,Sig=00000004,Obj=0x200012B8,State=0x00000DD5
0009701247 =>Intern Obj=0x200012B8,Sig=00000004,Obj=0x200012B8,State=0x00000DD5
0009702038 Disp===> Obj=0x20001278,Sig=00000004,Obj=0x20001278,State=0x00000DD5
0009702677 =>Intern Obj=0x20001278,Sig=00000004,Obj=0x20001278,State=0x00000DD5
0009703468 Disp===> Obj=0x20001238,Sig=00000004,Obj=0x20001238,State=0x00000DD5
0009704107 =>Intern Obj=0x20001238,Sig=00000004,Obj=0x20001238,State=0x00000DD5
0009704899 Disp===> Obj=0x200011F8,Sig=00000004,Obj=0x200011F8,State=0x00000DD5
0009705538 =>Intern Obj=0x200011F8,Sig=00000004,Obj=0x200011F8,State=0x00000DD5
0015961105 Disp===> Obj=0x200011F8,Sig=00000011,Obj=0x200011F8,State=0x00000DD5
===RTC===> St-Exit  Obj=0x200011F8,State=0x00000DD5
0015962823 Disp===> Obj=0x2000133C,Sig=00000010,Obj=0x2000133C,State=0x000010C5
0015963491 USER+000 0 hungry
. . . . . .
@endverbatim

And here is the exact same trace data when the "dictionaries" **are** available:

@verbatim
. . . . . .
0009692721 Disp===> Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
0009693389 PHILO_STAT 4 hungry
0009695383 PHILO_STAT 4 eating
0009695932 =>Intern Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
===RTC===> St-Entry Obj=l_philo[4],State=Philo_hungry
0009697188 ===>Tran Obj=l_philo[4],Sig=TIMEOUT_SIG,State=Philo_thinking->Philo_hungry
0009698052 Disp===> Obj=l_philo[4],Sig=EAT_SIG,State=Philo_hungry
===RTC===> St-Entry Obj=l_philo[4],State=Philo_eating
0009699697 ===>Tran Obj=l_philo[4],Sig=EAT_SIG,State=Philo_hungry->Philo_eating
0009700602 Disp===> Obj=l_philo[3],Sig=EAT_SIG,State=Philo_thinking
0009701247 =>Intern Obj=l_philo[3],Sig=EAT_SIG,State=Philo_thinking
0009702038 Disp===> Obj=l_philo[2],Sig=EAT_SIG,State=Philo_thinking
0009702677 =>Intern Obj=l_philo[2],Sig=EAT_SIG,State=Philo_thinking
0009703468 Disp===> Obj=l_philo[1],Sig=EAT_SIG,State=Philo_thinking
0009704107 =>Intern Obj=l_philo[1],Sig=EAT_SIG,State=Philo_thinking
0009704899 Disp===> Obj=l_philo[0],Sig=EAT_SIG,State=Philo_thinking
0009705538 =>Intern Obj=l_philo[0],Sig=EAT_SIG,State=Philo_thinking
0015961105 Disp===> Obj=l_philo[0],Sig=TIMEOUT_SIG,State=Philo_thinking
===RTC===> St-Exit  Obj=l_philo[0],State=Philo_thinking
0015962823 Disp===> Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
0015963491 PHILO_STAT 0 hungry
. . . . . .
@endverbatim

As you can see, the difference in readability is quite dramatic.


@section qspy_dict_get Acquiring Dictionaries
The QS Target-resident component generates the dictionary trace records during the initialization of active objects components in the Target code, that is, typically right after the reset. Consequently, the best way to acquire the dictionaries is to capture the trace when the Target performs the reset. This can be done in a couple of ways:
- Start QSPY **before** the Target resets
- Manually reset the Target while QSPY is running (e.g., press a Reset button on the Target board)
- Send the @ref qspy_keyboard "RESET command" to the Target from QSPY while it is running

Either way, the dictionary records should be produced and acquired by the Target. The following listing shows the dictionary records sent by the DPP example application running on a STM32 NUCLEO board:

<div style="height:40em;overflow:auto;">
@verbatim
C:\qp\qpc\examples\arm-cm\dpp_nucleo-l152re\qk\gnu>qspy -cCOM7
QQSPY 6.9.0 Copyright (c) 2005-2020 Quantum Leaps
Documentation: https://www.state-machine.com/qtools/qspy.html
Current timestamp: 200827_093625
-c COM7
-u 7701
-v 620
-T 4
-O 4
-F 4
-S 2
-E 2
-Q 1
-P 2
-B 2
-C 2

########## Trg-RST  QP-Ver=690,Build=200824_123230
           Obj-Dict 0x20001048->QS_RX
           Obj-Dict 0x08004009->l_SysTick_Handler
           Usr-Dict 00000100->PHILO_STAT
           Obj-Dict 0x20000EE0->AO_Table
           Obj-Dict 0x20000DDC->AO_Philo[0]
           Obj-Dict 0x20000E10->AO_Philo[1]
           Obj-Dict 0x20000E44->AO_Philo[2]
           Obj-Dict 0x20000E78->AO_Philo[3]
           Obj-Dict 0x20000EAC->AO_Philo[4]
           Obj-Dict 0x20000F94->EvtPool1
           Obj-Dict 0x20000DDC->Philo_inst[0]
           Obj-Dict 0x20000E00->Philo_inst[0].timeEvt
           Obj-Dict 0x20000E10->Philo_inst[1]
           Obj-Dict 0x20000E34->Philo_inst[1].timeEvt
           Obj-Dict 0x20000E44->Philo_inst[2]
           Obj-Dict 0x20000E68->Philo_inst[2].timeEvt
           Obj-Dict 0x20000E78->Philo_inst[3]
           Obj-Dict 0x20000E9C->Philo_inst[3].timeEvt
           Obj-Dict 0x20000EAC->Philo_inst[4]
           Obj-Dict 0x20000ED0->Philo_inst[4].timeEvt
           Fun-Dict 0x080006A9->Philo_initial
           Fun-Dict 0x08000915->Philo_thinking
           Fun-Dict 0x08000871->Philo_hungry
           Fun-Dict 0x080007C5->Philo_eating
           Sig-Dict 00000010,Obj=0x20000DDC->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000DDC->TIMEOUT_SIG
0000000000 AO-Subsc Obj=Philo_inst[0],Sig=00000004,Obj=0x20000DDC
0000000000 AO-Subsc Obj=Philo_inst[0],Sig=00000008,Obj=0x20000DDC
===RTC===> St-Init  Obj=Philo_inst[0],State=0x08001099->Philo_thinking
0000000000 TE0-Arm  Obj=Philo_inst[0].timeEvt,AO=Philo_inst[0],Tim=84,Int=0
===RTC===> St-Entry Obj=Philo_inst[0],State=Philo_thinking
0000000000 Init===> Obj=Philo_inst[0],State=Philo_thinking
           Sig-Dict 00000010,Obj=0x20000E10->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000E10->TIMEOUT_SIG
0000000000 AO-Subsc Obj=Philo_inst[1],Sig=00000004,Obj=0x20000E10
0000000000 AO-Subsc Obj=Philo_inst[1],Sig=00000008,Obj=0x20000E10
===RTC===> St-Init  Obj=Philo_inst[1],State=0x08001099->Philo_thinking
0000000000 TE0-Arm  Obj=Philo_inst[1].timeEvt,AO=Philo_inst[1],Tim=107,Int=0
===RTC===> St-Entry Obj=Philo_inst[1],State=Philo_thinking
0000000000 Init===> Obj=Philo_inst[1],State=Philo_thinking
           Sig-Dict 00000010,Obj=0x20000E44->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000E44->TIMEOUT_SIG
0000000000 AO-Subsc Obj=Philo_inst[2],Sig=00000004,Obj=0x20000E44
0000000000 AO-Subsc Obj=Philo_inst[2],Sig=00000008,Obj=0x20000E44
===RTC===> St-Init  Obj=Philo_inst[2],State=0x08001099->Philo_thinking
0000000000 TE0-Arm  Obj=Philo_inst[2].timeEvt,AO=Philo_inst[2],Tim=102,Int=0
===RTC===> St-Entry Obj=Philo_inst[2],State=Philo_thinking
0000000000 Init===> Obj=Philo_inst[2],State=Philo_thinking
           Sig-Dict 00000010,Obj=0x20000E78->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000E78->TIMEOUT_SIG
0000000000 AO-Subsc Obj=Philo_inst[3],Sig=00000004,Obj=0x20000E78
0000000000 AO-Subsc Obj=Philo_inst[3],Sig=00000008,Obj=0x20000E78
===RTC===> St-Init  Obj=Philo_inst[3],State=0x08001099->Philo_thinking
0000000000 TE0-Arm  Obj=Philo_inst[3].timeEvt,AO=Philo_inst[3],Tim=148,Int=0
===RTC===> St-Entry Obj=Philo_inst[3],State=Philo_thinking
0000000000 Init===> Obj=Philo_inst[3],State=Philo_thinking
           Sig-Dict 00000010,Obj=0x20000EAC->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20000EAC->TIMEOUT_SIG
0000000000 AO-Subsc Obj=Philo_inst[4],Sig=00000004,Obj=0x20000EAC
0000000000 AO-Subsc Obj=Philo_inst[4],Sig=00000008,Obj=0x20000EAC
===RTC===> St-Init  Obj=Philo_inst[4],State=0x08001099->Philo_thinking
0000000000 TE0-Arm  Obj=Philo_inst[4].timeEvt,AO=Philo_inst[4],Tim=51,Int=0
===RTC===> St-Entry Obj=Philo_inst[4],State=Philo_thinking
0000000000 Init===> Obj=Philo_inst[4],State=Philo_thinking
           Obj-Dict 0x20000EE0->Table_inst
           Sig-Dict 00000005,Obj=0x00000000->DONE_SIG
           Sig-Dict 00000004,Obj=0x00000000->EAT_SIG
           Sig-Dict 00000006,Obj=0x00000000->PAUSE_SIG
           Sig-Dict 00000007,Obj=0x00000000->SERVE_SIG
           Sig-Dict 00000008,Obj=0x00000000->TEST_SIG
           Sig-Dict 00000010,Obj=0x20000EE0->HUNGRY_SIG
0000000000 AO-Subsc Obj=Table_inst,Sig=DONE_SIG
0000000000 AO-Subsc Obj=Table_inst,Sig=PAUSE_SIG
0000000000 AO-Subsc Obj=Table_inst,Sig=SERVE_SIG
0000000000 AO-Subsc Obj=Table_inst,Sig=TEST_SIG
0000000000 PHILO_STAT 0 thinking
0000000000 PHILO_STAT 1 thinking
0000000000 PHILO_STAT 2 thinking
0000000000 PHILO_STAT 3 thinking
0000000000 PHILO_STAT 4 thinking
           Fun-Dict 0x08000BB5->Table_active
           Fun-Dict 0x08000BDD->Table_serving
           Fun-Dict 0x08000AD1->Table_paused
===RTC===> St-Init  Obj=Table_inst,State=0x08001099->Table_serving
===RTC===> St-Entry Obj=Table_inst,State=Table_serving
0000000000 Init===> Obj=Table_inst,State=Table_serving
           QF_RUN
@endverbatim
</div>

Once QSPY acquires the dictionaries, it keeps them in the memory and applies them to display the data in symbolic form (rather than hex addresses).

@note
The dictionaries do not need to be complete to be useful. QSPY simply applies the symbolic information whenever it can find a match in the dictionaries acquired so far. When a dictionary entry is not available, QSPY displays only hex addresses.


@section qspy_dict_save Saving Dictionaries to a File

QSPY can save the dictionaries acquired thus far into a file. This is triggered by the #QS_QF_RUN trace record from the Target, but it can also be triggered by the user (by means of the `d` @ref qspy_keyboard "keyboard command" or from @ref qview_file "QView menu File->Save Dictionaries"), because QSPY does not "know" when the dictionaries are "complete", therefore it cannot know when to save them automatically.

@note
For dictionaries to be saved to a file, the QSPY host application must be launched with the `-d` @ref qspy_command "command-line option", with of without the optional `[file]` parameter.


On the other hand, QSPY generates automatically the file name for saving dictionaries. This file name has always the form `qspy<target-time-stamp>.dic`, where `<target-time-stamp>` unambiguously identifies the Target build date and time. For example, the Target code last built on August 31, 2015 at 14:42:29 will have the name `qspy150831_144229.dic`.

@attention
The internal addresses of objects can change by every code re-build, so dictionaries are applicable only to the specific Target build and must be freshly re-acquired after every new Target code build.


The dictionaries are saved to a file in ASCII format. The following listing shows the dictionaries from the DPP example application running on a STM32 NUCLEO board:

<div style="height:40em;overflow:auto;">
@verbatim
-v690
-T4
-O4
-F4
-S2
-E2
-Q1
-P2
-B2
-C2
-t200824_123230

Obj-Dic:
4
0x08004009 l_SysTick_Handler
0x20000DDC Philo_inst[0]
0x20000E00 Philo_inst[0].timeEvt
0x20000E10 Philo_inst[1]
0x20000E34 Philo_inst[1].timeEvt
0x20000E44 Philo_inst[2]
0x20000E68 Philo_inst[2].timeEvt
0x20000E78 Philo_inst[3]
0x20000E9C Philo_inst[3].timeEvt
0x20000EAC Philo_inst[4]
0x20000ED0 Philo_inst[4].timeEvt
0x20000EE0 Table_inst
0x20000F94 EvtPool1
0x20001048 QS_RX
***
Fun-Dic:
4
0x080006A9 Philo_initial
0x080007C5 Philo_eating
0x08000871 Philo_hungry
0x08000915 Philo_thinking
0x08000AD1 Table_paused
0x08000BB5 Table_active
0x08000BDD Table_serving
***
Usr-Dic:
1
0x00000064 PHILO_STAT
0x0000007C QUTEST_ON_POST
***
Sig-Dic:
4
00000004 0x00000000 EAT_SIG
00000005 0x00000000 DONE_SIG
00000006 0x00000000 PAUSE_SIG
00000007 0x00000000 SERVE_SIG
00000008 0x00000000 TEST_SIG
00000010 0x20000E44 HUNGRY_SIG
00000010 0x20000EAC HUNGRY_SIG
00000010 0x20000E78 HUNGRY_SIG
00000010 0x20000DDC HUNGRY_SIG
00000010 0x20000E10 HUNGRY_SIG
00000010 0x20000EE0 HUNGRY_SIG
00000011 0x20000E78 TIMEOUT_SIG
00000011 0x20000EAC TIMEOUT_SIG
00000011 0x20000E44 TIMEOUT_SIG
00000011 0x20000DDC TIMEOUT_SIG
00000011 0x20000E10 TIMEOUT_SIG
***
@endverbatim
</div>


@section qspy_dict_use Using Dictionary File
The dictionary file saved in previous QSPY sessions can be used in two ways:

- you can specify the dictionary file in the `-d <dictionary_file>` @ref qspy_command "command-line option" to QSPY. In this case QSPY reads the dictionaries from the provided `<dictionary_file>` before processing any trace records from the Target. (**NOTE:** in this case you don't need to provide any of the upper-case command-line options, because they are read from the dictionary file.) For example: command line: `qspy -d qspy180117_155932.dic` will attempt to read the dictionaries from the specified file.

- you can specify the dictionary option without the dictionary file `-d` @ref qspy_command "command-line option" to QSPY. Subsequently, once you run QSPY, you can query the Target information (by means of the `i` or `r` @ref qspy_keyboard "keyboard command" or from @ref qview_menu "QView menu Commands->Query Target Info"). When the Target replies and provides its build-time-stamp, QSPY looks for the corresponding dictionary file in the current directory and if such a file is found, QSPY reads the dictionaries from it.


@note
That last option requires that the Target implements the @ref qs_rx "QS receive channel, QS-RX" so that it can receive commands from QSPY.

@nav{qspy_text,qspy_udp}
*/
/*##########################################################################*/
/**
@page qspy_udp QSPY UDP Interface
@nav{qspy_dict,qspy_seq}

@tableofcontents

<p>This section describes the structure of the UDP packets exchanged between the QSPY Back-End and the various front-ends, such as @ref qutest "QUTest" and @ref qview "QView"  (<span style="color:blue"><strong>blue arrows</strong></span> in the sequence diagram below).
</p>

@image html qspy_comm.gif "Communication between Target, QSPY, and QView"
@n


@section udp_top General UDP Packet Structure

@image html qspy_udp.gif "UDP packet structure"

The UDP packets exchanged between the QSPY Back-End and the `QView` Front-End consists of:

- 1-byte **Sequence-No**, which increments by 1 for every packet and wraps naturally from 0xFF to 0. The sequence number allows `QView` to detect any data discontinuities.

- 1-byte **Record-ID**. The Record-IDs are divided into two categories:
    - Records to and from the Target have Record-IDs in the range <strong>0..127</strong>. Specifically, QS records originated from the Target are enumerated in ::QSpyRecords. Records destined to the Target are enumerated in ::QSpyRxRecords.
    - Records to and from the QSPY Back-End have record-IDs in the range <strong>128..255</strong>. Specifically, records destined to QSPY are enumerated in ::QSpyCommands.

- optional **Data Payload**, which can be either text or binary, depending on the @ref udp_channel "UDP Channel" to which the front-end attaches. The various Data Payloads for different packets are described in the separate sections below.



@subsection udp_channel UDP Data Channels
The QSPY UDP socket supports two "channels":
- **binary channel** (channel 1), in which the *Data Payload* is sent in binary, but after removing @ref qspy_transparent "escaping" and checksum;
- **text channel** (channel 2), in which the *Data Payload* is sent in the @ref qspy_text "QSPY Textual Format";

A Front-End can choose the "data channels" when "attaching" to the QSPY host application (see qspy::attach()). The data channels are not exclusive, meaning that a front-end can "attach" simultaneously to both binary and text channels. In this case, the front-end would receive each packet as both binary and text formats.

@remark
The binary-channel (0x01) is used by the @ref qview "QView" GUI front-end, while the text-channel (0x02) is used by the @ref qutest "QUTest" Unit Testing front-end.


@section udp_Target Records to the Target


@subsection udp_INFO  Query Target Info (INFO)
This packet has Record-ID==INFO and has no Data Payload.

@note
To understand the following detailed UDP packet descriptions, it is highly recommended to read the Python documentation for the  <a href="https://docs.python.org/2.6/library/struct.html" target="_blank" class="extern"><b>Python struct.pack() command</b></a>.@n
@n
All data to and from the Target are sent according to the @ref qpspy_proto "QP/Spy&trade; Data Protocol" in **little endian**.


<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format c $::qspy::QS_RX(INFO)]
@endcode



@subsection udp_COMMAND Execute a User-Defined Command in the Target (COMMAND)
This packet has Record-ID==COMMAND and Data Payload of the form:

Data item  | binary format               | description
-----------|-----------------------------|-------------
Command-ID | B (byte)                    | command number
Command-Par| I (unsigned 4-byte integer) | command parameter


@subsection udp_RESET  Reset the Target (RESET)
This packet has Record-ID==RESET and has no Data Payload.


@subsection udp_TICK  Call QF_TICK_X() in the Target (TICK)

Data item  | binary format | description
-----------|---------------|-------------
Tick-rate  | B (byte)      | system tick rate number


@subsection udp_PEEK  Peek Target Memory (PEEK)
This packet has Record-ID==PEEK and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Peek-addr  | Target-dependent@n Typically I | Address of the data in the Target
Peek-length| B (byte)      | Number of bytes to peek


@subsection udp_POKE  Poke Target Memory (POKE)
This packet has Record-ID==POKE and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Poke-addr  | Target-dependent@n Typically I | Address of the data in the Target
Poke-length| B (byte)      | Number of bytes to poke (<= 8)
Poke-data  | user-defined  | Binary data to poke to the Target (8 bytes maximum)

@note
The Poke-data part of the Data Payload must be formatted with the particular endianness of the Target and with any padding required for proper alignment of objects in the Target memory.


@subsection udp_GLB_FILTER  Set Global Filters in the Target (GLB_FILTER)
This packet has Record-ID==GLB_FILTER and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Data Len   | B (byte)      | Number of bytes sent (currently 16)
Filters    | 16B           | 8-bytes (128-bits), each bit corresponding to Global Filter


@subsection udp_LOC_FILTER  Set Local Filters in the Target (LOC_FILTER)
This packet has Record-ID==LOC_FILTER and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Local filter #| B (byte)         | The Number of the Local Filter
Object-addr   | Target-dependent@n Typically I | Address of the object in the Target

The Local filters are numbered as follows:

0. State Machine Local Filter (SM)
1. Active Object Local Filter (AO)
2. Memory Pool Local Filter (MP)
3. Event Queue Local Filter (EQ)
4. Time Event Local Filter (TE)
5. Application-Specific Local Filter (AP)


@subsection udp_AO_FILTER  Set Local AO Filter in the Target (AO_FILTER)
This packet provides a shortcut for setting the Active Object Local Filter by providing just the unique priority of the AO.
The packet has Record-ID==AO_FILTER and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
AO prio    | B (byte)      | Priority of the AO to filter (0 to disable the AO filter)



@subsection udp_EVENT  Inject an Event to the Target (EVENT)
This packet has Record-ID==EVENT and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
AO prio    | B (byte)      | Priority of the recipient AO (0 to publish the event)
signal     | Target-dependent@n Typically H | signal of the event
parameters | user-defined  | Binary data corresponding to all event parameters

The Event signal `sig` must be formatted according to the Target configuration (see <a href="https://www.state-machine.com/qpc/qep_8h.html#afdaa94c40e947b0340b4259eddce3561" target="_blank" class="extern">Q_SIGNAL_SIZE</a>)

The Event **parameters** must be formatted with the particular **endianness** of the Target and with any padding required for proper alignment of objects in the Target memory.

The parameters need to match exactly the event memory layout in your Target, including the endianness and any padding that the Target compiler might be using. (To test the right binary format and padding, you can use the @ref qview_events "Generate Event..." command).

For example, let's assume that the parameters of your event are: a byte, followed by a 2-byte integer, followed by a 4-byte integer. Also, let's assume that your Target is little endian. From the @ref qview_events "Generate Event..." command you discover that to format this event correctly you need to use the following event parameters:

Par # | format | data (example)
------|--------|-------------
par1: | B      | 0x11
par2: | B      | 0x00
par3: | H      | 0x1122
par4: | I      | 0x11223344


@section udp_QSPY Packets to the QSPY Back-End


@subsection udp_ATTACH  Attach to the QSPY Back-End (ATTACH)
This packet has Record-ID==ATTACH and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
channels   | B (byte)      | Binary bitmask of @ref udp_channel "QSPY channels" to attach to


@subsection udp_DETACH Detach from the QSPY Back-End (DETACH)
This packet has Record-ID==DETACH and has no Data Payload.


@subsection udp_SAVE_DIC  Save Dictionaries to a File in QSPY (SAVE_DIC)
This packet has Record-ID==SAVE_DIC and has no Data Payload.


@subsection udp_SCREEN_OUT Toggle Screen Output to a File in QSPY (SCREEN_OUT)
This packet has Record-ID==SCREEN_OUT and has no Data Payload.


@subsection udp_BIN_OUT Toggle Binary Output to a File in QSPY (BIN_OUT)
This packet has Record-ID==BIN_OUT and has no Data Payload.


@subsection udp_MATLAB_OUT Toggle MATLAB Output to a File in QSPY (MATLAB_OUT)
This packet has Record-ID==MATLAB_OUT and has no Data Payload.


@subsection udp_SEQUENCE_OUT Toggle Sequence Output to a File in QSPY (SEQUENCE_OUT)
This packet has Record-ID==SEQUENCE_OUT and has no Data Payload.



@section udp_from Packets from the QSPY Back-End


@subsection udp_from_ATTACH  Attach Response from the QSPY Back-End (ATTACH)
This packet has Record-ID==ATTACH and has no Data Payload.


@subsection udp_from_DETACH  Detach Request from the QSPY Back-End (DETACH)
This packet has Record-ID==DETACH and has no Data Payload.

@nav{qspy_dict,qspy_seq}
*/
/*###########################################################################*/
/**
@page qspy_seq QSPY Sequence Output

@tableofcontents
@nav{qspy_udp,qspy_matlab}

<p>The QSPY host application can also present the tracing data as a **sequence diagram**. To generate a Sequence file, you need to invoke QSPY with  the `-g [obj-list]` @ref qspy_command "command-line option".
</p>

The `[obj-list]` is a comma-separated list of objects shown in the sequence. The names in the list must correspond exactly to the @ref qs_dict "object dictionaries" produced by the Target. Examples of the valid `-g` options are shown below:

- `-g -g l_SysTick_Handler,Table::inst,Philo::inst[0],Philo::inst[1]`
- `-g l_QF_onClockTick,TServer::inst`

Additionally, the list could include `?` (questionmark), which denotes @ref qspy_seq_sys "System Border".

- `-g -g Table::inst,Philo::inst[0],Philo::inst[1],?`
- `-g ?,l_QF_onClockTick,TServer::inst`


@note
The Sequence diagram can show only information actually sent from the Target. Therefore, by adjusting @ref qs_filters "QS filters" you can control the kind of information displayed in the sequence.


The following QS trace records produce the most interesting output:
- #QS_QF_ACTIVE_POST,
- #QS_QF_ACTIVE_POST_ATTEMPT,
- #QS_QF_ACTIVE_POST_LIFO,
- #QS_QF_PUBLISH, and
- #QS_QF_TICK.


Additional annotations of the sequence diagrams are also available if the following QS trace records are enabled:
- #QS_QEP_TRAN,
- #QS_QF_ACTIVE_DEFER,
- #QS_QF_ACTIVE_RECALL, and
- #QS_QF_ACTIVE_RECALL_ATTEMPT.



@section qspy_seq_ref Sequence Elements
The main elements of the QSPY sequence diagram shown in the following sequence output are marked with the `[xx]` labels, which are explained below the listing.

@note
The sequence output generated by QSPY is a **simple ASCII file**, which you can browse even with the most basic text editor, or a web browser. **No special tools are needed to view the sequence diagrams produced from your data**.


@verbatim
[1]  -g ?,l_QF_onClockTick,TServer::inst

                +-------+-------+   +-------+-------+   +-------+-------+
[2]             |       ?       |   |l_QF_onClockTic|   | TServer::inst |
                +-------+-------+   +-------+-------+   +-------+-------+
[3]  3115372171         /                   |                   |
[4]  3127751904         *--NEW_REQUEST_SIG--+------------------>|
[5]  3127792184         /                   |           <TServer::receiv>
     3144424365         /                   *--RECEIVED_SIG---->|
     3144429488         /                   |           <TServer::author>
     3177742936         /                   *--AUTHORIZED_SIG-->|
[6]  3177796020         /                   |                (RcallA)
     3177816231         /                   |            <TServer::idle>
     3190753295         *--NEW_REQUEST_SIG--+------------------>|
     3190792988         /                   |           <TServer::receiv>
     3200126862         *--NEW_REQUEST_SIG--+------------------>|
[7]  3200127346         /                   |                (Defer)
     3207429692         /                   *--RECEIVED_SIG---->|
     3207435638         /                   |           <TServer::author>
     3240835283         /                   *--AUTHORIZED_SIG-->|
[8]  3240884412         /                   |                   *<=NEW_REQUEST_SIG]
     3240884486         /                   |                (RCall)
     3240902469         /                   |            <TServer::idle>
     . . . . .         . . .              . . .                . . .
@endverbatim

<dl class="tag">
  <dt>1</dt><dd> The sequence diagram starts with repeating the `-g [obj-list]` option, so that you can conveniently copy-and-paste this option to run the same sequence again.
  </dd>
  <dt>2</dt><dd> Below that, you can see the header containing the boxes of participating objects from the `[obj-list]`. From each box descends a **lifeline** that runs vertically down the page and represents the ordering of exchanged events and other interesting occurrences involving a given object.
> **NOTE:** This first object in this particular sequence diagram, denoted as`?', is the @ref qspy_seq_sys explained below.

> **NOTE:** The names in the sequence diagram are **truncated** to the first 15 characters.

> **NOTE:** The sequence header is **repeated** every 100 lines of the sequence output.
  </dd>
  <dt>3</dt><dd> Each output line starts with the **timestamp** followed by the life-lines of all participating objects with event arrows or annotations.
  </dd>
  <dt>4</dt><dd> This line shows a **event posting** (with FIFO policy), which corresponds to the QS records #QS_QF_ACTIVE_POST and #QS_QF_ACTIVE_POST_ATTEMPT. The event **source** is marked with `*`, the event **target** is pointed to with `>` or `<`. The source and target are connected with a line `*----->`. The line is annotated with the **signal** of the posted event.
  </dd>
  <dt>5</dt><dd> This line shows a **state change**, which corresponds to the QS record #QS_QEP_TRAN. The lifeline of the object is annotated with new **state** assumed by the object. The state-name is placed between  `<` or `>`.
  </dd>
  <dt>6</dt><dd> This line shows a **event recall**, which corresponds to the QS records #QS_QF_ACTIVE_RECALL, and #QS_QF_ACTIVE_RECALL_ATTEMPT. The lifeline of the object is annotated with `(Rcall)` or `(RcallA)`, respectively.
  </dd>
  <dt>7</dt><dd> This line shows a **event deferral**, which corresponds to the QS record #QS_QF_ACTIVE_DEFER. The lifeline of the object is annotated with `(Defer)`.
  </dd>
  <dt>8</dt><dd> This line shows a **event self-posting** with LIFO policy, which corresponds to the QS record #QS_QF_ACTIVE_POST_LIFO. The event **source/target** is marked with `*<`, the LIFO policy of the event posting is denoted by the `=` line right before the **signal** of the posted event.
  </dd>
</dl>
<div style="clear:both;"></div>


@section qspy_seq_sys The System Border Object
As mentioned before, the `[obj-list]` that specifies objects participating in the sequence might include `?` (questionmark), which denotes @ref qspy_seq_sys "System Border". The system border is the "environment" that can produce and consume events. The "System Border" denotes possibly **multiple objects** that are not explicitly listed in the `[obj-list]`, including even objects without @ref qs_dict "object dictionaries". The sequence diagram in the previous section shows the "System Border", labeled as `?` and life-line shown as `//////`.

@note
You can place the "System Border" (the `?`) anywhere in the `[obj-list]`. However, it is customary to place it either as the very first or the very last object in the list, as shown in the sequence diagram below:


The listing below shows a sequence output (`.seq`) generated from the Deferred Event example application with the following `-g` option:

`-g ?,l_QF_onClockTick,TServer::inst`



@section qspy_seq_exa More Involved Example
The listing below shows an example of a more involved sequence diagram output (`.seq`) generated from the Dining Philosophers Problem (DPP) application with the following `-g` option:

`-g l_SysTick_Handler,Table::inst,Philo::inst[0],Philo::inst[1],Philo::inst[2],Philo::inst[3],Philo::inst[4]`


In addition to the elements described above, this sequence diagram illustrates the **event publishing**, which corresponds to the #QS_QF_PUBLISH trace record. The event multicasting is represented as a horizontal line `. . . .`, with the event **source** marked as `*`.


<div style="height:40em;overflow:auto;">
@verbatim
-g l_SysTick_Handler,Table::inst,Philo::inst[0],Philo::inst[1],Philo::inst[2],Philo::inst[3],Philo::inst[4]

           +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+
           |l_SysTick_Handl|   |  Table::inst  |   |Philo::inst[0] |   |Philo::inst[1] |   |Philo::inst[2] |   |Philo::inst[3] |   |Philo::inst[4] |
           +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+   +-------+-------+
0000042339 . . . . * .SERVE_SIG. . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0000042896         *--SERVE_SIG------->|                   |                   |                   |                   |                   |
0001070723         *--TIMEOUT_SIG------+-------------------+-------------------+-------------------+-------------------+------------------>|
0001075362         |                   |<------------------+-------------------+-------------------+-------------------+-------HUNGRY_SIG--*
0001079065 . . . . | . . . . . . . . . * .EAT_SIG. . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0001079975         |                   *--EAT_SIG----------+-------------------+-------------------+-------------------+------------------>|
0001080774         |                   *--EAT_SIG----------+-------------------+-------------------+------------------>|                   |
0001081583         |                   *--EAT_SIG----------+-------------------+------------------>|                   |                   |
0001082382         |                   *--EAT_SIG----------+------------------>|                   |                   |                   |
0001083181         |                   *--EAT_SIG--------->|                   |                   |                   |                   |
0001087412         |                   |                   |                   |                   |                   |            <Philo::hungry>
0001091293         |                   |                   |                   |                   |                   |            <Philo::eating>
0001762885         *--TIMEOUT_SIG------+------------------>|                   |                   |                   |                   |
0001767416         |                   |<------HUNGRY_SIG--*                   |                   |                   |                   |
0001772368         |                   |            <Philo::hungry>            |                   |                   |                   |
0002097460 . . . . * .PAUSE_SIG. . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0002098016         *--PAUSE_SIG------->|                   |                   |                   |                   |                   |
0002101049         |            <Table::paused>            |                   |                   |                   |                   |
0002140275         *--TIMEOUT_SIG------+-------------------+-------------------+------------------>|                   |                   |
0002144842         |                   |<------------------+-------------------+-------HUNGRY_SIG--*                   |                   |
0002149765         |                   |                   |                   |            <Philo::hungry>            |                   |
0002245145         *--TIMEOUT_SIG------+-------------------+------------------>|                   |                   |                   |
0002249676         |                   |<------------------+-------HUNGRY_SIG--*                   |                   |                   |
0002254599         |                   |                   |            <Philo::hungry>            |                   |                   |
0003104906         *--TIMEOUT_SIG------+-------------------+-------------------+-------------------+------------------>|                   |
0003109447         |                   |<------------------+-------------------+-------------------+-------HUNGRY_SIG--*                   |
0003114370         |                   |                   |                   |                   |            <Philo::hungry>            |
0005013277         *--TIMEOUT_SIG------+-------------------+-------------------+-------------------+-------------------+------------------>|
0005016745 . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . DONE_SIG. * . . .
0005017655         |                   |<------------------+-------------------+-------------------+-------------------+---------DONE_SIG--*
0005025076         |                   |                   |                   |                   |                   |           <Philo::thinking>
0007760487         *--TIMEOUT_SIG------+-------------------+-------------------+-------------------+-------------------+------------------>|
0007764998         |                   |<------------------+-------------------+-------------------+-------------------+-------HUNGRY_SIG--*
0007769921         |                   |                   |                   |                   |                   |            <Philo::hungry>
0011827861 . . . . * .SERVE_SIG. . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0011828417         *--SERVE_SIG------->|                   |                   |                   |                   |                   |
0011832381 . . . . | . . . . . . . . . * .EAT_SIG. . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0011833291         |                   *--EAT_SIG----------+-------------------+-------------------+-------------------+------------------>|
0011834089         |                   *--EAT_SIG----------+-------------------+-------------------+------------------>|                   |
0011834887         |                   *--EAT_SIG----------+-------------------+------------------>|                   |                   |
0011835685         |                   *--EAT_SIG----------+------------------>|                   |                   |                   |
0011836483         |                   *--EAT_SIG--------->|                   |                   |                   |                   |
0011839510 . . . . | . . . . . . . . . * .EAT_SIG. . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0011840421         |                   *--EAT_SIG----------+-------------------+-------------------+-------------------+------------------>|
0011841199         |                   *--EAT_SIG----------+-------------------+-------------------+------------------>|                   |
0011841977         |                   *--EAT_SIG----------+-------------------+------------------>|                   |                   |
0011842755         |                   *--EAT_SIG----------+------------------>|                   |                   |                   |
0011843533         |                   *--EAT_SIG--------->|                   |                   |                   |                   |
0011846001         |            <Table::serving>           |                   |                   |                   |                   |
0011864225         |                   |                   |                   |            <Philo::eating>            |                   |
0011874191         |                   |            <Philo::eating>            |                   |                   |                   |
0015268086         *--TIMEOUT_SIG------+-------------------+-------------------+------------------>|                   |                   |
0015271590 . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . * .DONE_SIG . . . . | . . . . . . . . . | . . .
0015272500         |                   |<------------------+-------------------+---------DONE_SIG--*                   |                   |
0015276635 . . . . | . . . . . . . . . * .EAT_SIG. . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0015277545         |                   *--EAT_SIG----------+-------------------+-------------------+-------------------+------------------>|
0015278343         |                   *--EAT_SIG----------+-------------------+-------------------+------------------>|                   |
0015279141         |                   *--EAT_SIG----------+-------------------+------------------>|                   |                   |
0015279939         |                   *--EAT_SIG----------+------------------>|                   |                   |                   |
0015280737         |                   *--EAT_SIG--------->|                   |                   |                   |                   |
0015289641         |                   |                   |                   |                   |            <Philo::eating>            |
0015294035         |                   |                   |                   |           <Philo::thinking>           |                   |
0015540732         *--TIMEOUT_SIG------+------------------>|                   |                   |                   |                   |
0015544272 . . . . | . . . . . . . . . | . . . . . . . . . * .DONE_SIG . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0015545182         |                   |<--------DONE_SIG--*                   |                   |                   |                   |
0015549317 . . . . | . . . . . . . . . * .EAT_SIG. . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . . . . . . . . | . . .
0015550227         |                   *--EAT_SIG----------+-------------------+-------------------+-------------------+------------------>|
0015551025         |                   *--EAT_SIG----------+-------------------+-------------------+------------------>|                   |
0015551823         |                   *--EAT_SIG----------+-------------------+------------------>|                   |                   |
0015552621         |                   *--EAT_SIG----------+------------------>|                   |                   |                   |
0015553419         |                   *--EAT_SIG--------->|                   |                   |                   |                   |
0015567245         |                   |                   |            <Philo::eating>            |                   |                   |
0015571639         |                   |           <Philo::thinking>           |                   |                   |                   |
@endverbatim
</div>

@next{qspy_matlab}
*/
/*###########################################################################*/
/**
@page qspy_matlab QSPY MATLAB Support

@tableofcontents
@nav{qspy_seq,qutest}

<p>The QSPY host application can also export trace data to <a href="http://www.mathworks.com/products/matlab/" target="_blank" class="extern">MATLAB</a>&reg;, which is a popular numerical computing environment and a high-level technical programming language. Created by The MathWorks, Inc., MATLAB allows easy manipulation and plotting of data represented as matrices.
</p>

@note
The QSPY MATLAB interface is also compatible with the <a href="http://www.gnu.org/software/octave/" target="_blank" class="extern">GNU Octave</a> environment, which is an open source alternative to MATLAB and is compatible with the QSPY MATLAB interface described below.

The following sections provide a reference manual for all 11 the MATLAB matrices generated by the @c qspy.m script. By MATLAB convention, the different variables are put into columns, allowing observations to vary down
through the rows. Therefore, a data set consisting of twenty four time samples of six variables is stored in a matrix of size 24-by-6. The pound sign '#' in a given cell of the matrix represents data available from the target. Other values, represent data added by the @c qspy.m script to allow unambiguous identification of the trace records.

- @ref MATLAB_Q_STATE
- @ref MATLAB_Q_ACTIVE
- @ref MATLAB_Q_EQUEUE
- @ref MATLAB_Q_MPOOL
- @ref MATLAB_Q_NEW
- @ref MATLAB_Q_PUB
- @ref MATLAB_Q_TIME
- @ref MATLAB_Q_INT
- @ref MATLAB_Q_ISR
- @ref MATLAB_Q_MUTEX
- @ref MATLAB_Q_SCHED


@section MATLAB_Q_STATE Q_STATE Matrix
<p>The N-by-6 @c Q_STATE matrix stores all QS records generated by the QEP hierarchical event processor and pertaining to all the state machines in the system. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Signal</th>
    <th>State@n Machine@n Object</th>
    <th>Source@n State</th>
    <th>New@n State</th>
    <th>Event@n Hanlder</th>
  </tr>

  <tr>
    <td>@c #QS_QEP_STATE_ENTRY</td>
    <td>NaN</td>
    <td>1</td>
    <td>#(2)</td>
    <td>#</td>
    <td>NaN</td>
    <td>1</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_STATE_EXIT</td>
    <td>NaN</td>
    <td>2</td>
    <td>#(2)</td>
    <td>#</td>
    <td>NaN</td>
    <td>1</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_STATE_INIT</td>
    <td>NaN</td>
    <td>3</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>1</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_INIT_TRAN</td>
    <td>#</td>
    <td>3</td>
    <td>#(2)</td>
    <td>NaN</td>
    <td>#</td>
    <td>1</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_INTERN_TRAN</td>
    <td>#</td>
    <td>#(1)</td>
    <td>#(2)</td>
    <td>#</td>
    <td>NaN</td>
    <td>1</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_TRAN</td>
    <td>#</td>
    <td>#(1)</td>
    <td>#(2)</td>
    <td>#</td>
    <td>#</td>
    <td>1</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_IGNORED</td>
    <td>#</td>
    <td>#(1)</td>
    <td>#(2)</td>
    <td>#</td>
    <td>NaN</td>
    <td>0</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_DISPATCH</td>
    <td>#</td>
    <td>#(1)</td>
    <td>#(2)</td>
    <td>#</td>
    <td>NaN</td>
    <td>0</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_UNHANDLED</td>
    <td>NaN</td>
    <td>#(1)</td>
    <td>#(2)</td>
    <td>#</td>
    <td>NaN</td>
    <td>0</td>
  </tr>
</table>
</center>

(1) The valid USER signal is &gt; 3

(2) Per inheritance, an active object is a state machine object as well


The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_STATE matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QEP_STATE_ENTRY</td>
    <td>`Q_STATE(:,2) == 1`</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_STATE_EXIT</td>
    <td>`Q_STATE(:,2) == 2`</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_STATE_INIT</td>
    <td>`Q_STATE(:,2) == 3`</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_INIT_TRAN</td>
    <td>`isnan(Q_STATE(:,4))`</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_INTERN_TRAN</td>
    <td>`Q_STATE(:,2) &gt; 3 & isnan(Q_STATE(:,5))`</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_TRAN</td>
    <td>`Q_STATE(:,2) > &gt; & ~isnan(Q_STATE(:,5))`</td>
  </tr>

  <tr>
    <td>@c #QS_QEP_IGNORED</td>
    <td>`~Q_STATE(:,6)`</td>
  </tr>
</table>
</center>

For example, the following MATLAB plot shows the timing diagrams for all Philo state machines in the DPP example application made by the `philo_timing.m` script located in the directory `qtools/qspy/matlab` (see Section @ref qspy_files). The vertical axis represents states "thinking" (lowest), "hungry" (middle) and "eating" (top) states.

@image html FigQSPY.01.jpg "Timing diagrams for all Philo state machines."


@section MATLAB_Q_ACTIVE Q_ACTIVE Matrix
<p>The N-by-5 @c Q_ACTIVE matrix stores QS records pertaining to adding/removing active objects and subscribing/unsubscribing to events from active objects. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Signal</th>
    <th>Active@n Object</th>
    <th>QF@n Priority</th>
    <th>Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_SUBSCRIBE</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_UNSUBSCRIBE</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>-1</td>
  </tr>
</table>
</center>

The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_ACTIVE matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_SUBSCRIBE</td>
    <td>`isnan(Q_ACTIVE(:,4)) & Q_ACTIVE(:,5) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_UNSUBSCRIBE</td>
    <td>`isnan(Q_ACTIVE(:,4)) & Q_ACTIVE(:,5) &lt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_EQUEUE Q_EQUEUE Matrix
<p>The N-by-10 @c Q_EQUEUE matrix stores QS records pertaining to queuing events in the QF. Both the active object event queues and the "raw" thread-safe queues are included. The 'nUsed' field denotes the current number of used entries in the queue. The 'Maximum nUsed' filed denotes the maximum number of used entries since initialization (high watermark). Both fields contain the number of used entries in the queues ring-buffer plus one, to account for the extra location at the front of the queue. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
    <th>8</th>
    <th>9</th>
    <th>10</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Sender</th>
    <th>Event@n Queue (1)</th>
    <th>nFree</th>
    <th>Minimum@n Used</th>
    <th>Signal</th>
    <th>Pool ID</th>
    <th>Ref.@n Count</th>
    <th>LIFO</th>
    <th>Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_POST</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>0</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_POST_LIFO</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>1</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_GET</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>0</td>
    <td>-1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_GET_LAST</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>0</td>
    <td>-1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_POST</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>1</td>
    <td>#</td>
    <td>0</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_POST_LIFO</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>1</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_GET</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>0</td>
    <td>-1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_GET_LAST</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>0</td>
    <td>-1</td>
  </tr>
</table>
</center>

(1) This field (index 3) is actually the pointer to the ring buffer of the queue.

The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_EQUEUE matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_POST</td>
    <td>`Q_EQUEUE(:,3) == &lt;active obj&gt; & ~Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_POST_LIFO</td>
    <td>`Q_EQUEUE(:,3) == &lt;active obj&gt; & Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_GET</td>
    <td>`Q_EQUEUE(:,3) == &lt;active obj&gt; & ~isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ACTIVE_GET_LAST</td>
    <td>`Q_EQUEUE(:,3) == &lt;active obj&gt; & isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_POST</td>
    <td>`Q_EQUEUE(:,3) == &lt;raw queue&gt; & ~Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_POST_LIFO</td>
    <td>`Q_EQUEUE(:,3) == &lt;raw queue&gt; & Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_GET</td>
    <td>`Q_EQUEUE(:,3) == &lt;raw queue&gt; & ~isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_EQUEUE_GET_LAST</td>
    <td>`Q_EQUEUE(:,3) == &lt;raw queue&gt; & isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_MPOOL Q_MPOOL Matrix
<p>The N-by-5 @c Q_MPOOL matrix stores QS records pertaining to memory pools in the QF. The 'nFree' field denotes the current number of free blocks in the event pool. The 'Minimum nFree' filed denotes the minimal number of free blocks since initialization (low watermark). The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Pool@n Object</th>
    <th>nFree</th>
    <th>Minimal@n nFree</th>
    <th>Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_MPOOL_GET</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>-1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_MPOOL_PUT</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>+1</td>
  </tr>
</table>
</center>

The cumulative sum over the 'Delta' column should not have any long-time trends, because this would indicate a leak from the pool. The following picture shows the plot for the test data.

@image html FigQSPY.02.jpg "Plot stairs(Q_MPOOL(:,1), cumsum(Q_MPOOL(:,5)))"

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_MPOOL matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_MPOOL_GET</td>
    <td>`Q_MPOOL(:,5) &lt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_MPOOL_PUT</td>
    <td>`Q_MPOOL(:,5) &gt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_NEW Q_NEW Matrix
<p>The N-by-6 @c Q_NEW matrix stores QS records pertaining to dynamic event allocation and automatic event recycling (garbage collection) in the QF. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Signal</th>
    <th>PoolID</th>
    <th>Ref.@n Count</th>
    <th>Event@n Size</th>
    <th>Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_NEW</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>#</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_GC_ATTEMPT</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>0</td>
  </tr>

  <tr>
    <td>@c #QS_QF_GC</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>-1</td>
  </tr>
</table>
</center>

The cumulative sum over the 'Delta' column should not have any long-time trends, because this would indicate event leak. The following picture shows the plot for the test data.

@image html FigQSPY.03.jpg "Plot stairs(Q_NEW(:,1), cumsum(Q_NEW(:,6)))"

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_NEW matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_NEW</td>
    <td>`Q_NEW(:,6) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_GC_ATTEMPT</td>
    <td>`Q_NEW(:,6) == 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_GC</td>
    <td>`Q_NEW(:,6) &lt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_PUB Q_PUB Matrix
<p>The N-by-7 @c Q_PUB matrix stores QS records pertaining to publishing events in QF. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Sender</th>
    <th>Signal</th>
    <th>PoolID</th>
    <th>Ref.@n Count</th>
    <th># Events@n Multicast</th>
    <th>Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_PUBLISH</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
  </tr>
</table>
</center>

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_PUB matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_PUBLISH</td>
    <td>`Q_PUB(:,7) &gt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_TIME Q_TIME Matrix
<p>The N-by-7 @c Q_TIME matrix stores QS records pertaining to time events in QF. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>QTimeEvt@n Object</th>
    <th>Signal</th>
    <th>QActive@n Object</th>
    <th>QTimeEvt@n Counter</th>
    <th>QTimeEvt@n Interval</th>
    <th>QTimeEvt@n Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_TICK</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>#(1)</td>
    <td>NaN</td>
    <td>0</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_ARM</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_DISARM</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>-1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_AUTO_DISARM</td>
    <td>NaN</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>-1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_DISARM_ATTEMPT</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>0</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_REARM</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#(2)</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_POST</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>NaN</td>
    <td>NaN</td>
    <td>0</td>
  </tr>
</table>
</center>

(1) For #QS_QF_TICK record this matrix element contains the Tick Counter.

(2) For #QS_QF_TIMEEVT_REARM event this matrix element is 0 if the time event was disarmed and rearmed again, and 1 if the time event was only armed.

The cumulative sum over the 'Delta' column indicates the total number of armed time events at any given time. The following picture shows the plot for the test data:

@image html FigQSPY.04.jpg "Plot stairs(Q_TIME(:,1), cumsum(Q_TIME(:,7)))"

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_TIME matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_TICK</td>
    <td>`isnan(Q_TIME(:,2))`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_ARM</td>
    <td>`Q_TIME(:,7) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_DISARM</td>
    <td>`~isnan(Q_TIME(:,1)) & Q_TIME(:,7) &lt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_AUTO_DISARM</td>
    <td>`isnan(Q_TIME(:,1)) & Q_TIME(:,7) &lt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_DISARM_ATTEMPT</td>
    <td>`isnan(Q_TIME(:,3)) & isnan(Q_TIME(:,5)) & Q_TIME(:,7) == 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_REARM</td>
    <td>`isnan(Q_TIME(:,3)) & ~isnan(Q_TIME(:,5))`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_TIMEEVT_POST</td>
    <td>`~isnan(Q_TIME(:,3)) & ~isnan(Q_TIME(:,4))`</td>
  </tr>
</table>
</center>

@section MATLAB_Q_INT Q_INT Matrix
<p>The N-by-3 @c Q_INT matrix stores QS records pertaining to interrupt disabling and enabling. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Interrupt@n Nesting</th>
    <th>Nesting@n Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_INT_DISABLE</td>
    <td>#</td>
    <td>#</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_INT_ENABLE</td>
    <td>#</td>
    <td>#</td>
    <td>-1</td>
  </tr>
</table>
</center>

The cumulative sum over the 'Delta' column indicates interrupt lock nesting
and should closely follow column 2.

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_INT matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_INT_DISABLE</td>
    <td>`Q_INT(:,3) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_INT_ENABLE</td>
    <td>`Q_INT(:,3) &lt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_ISR Q_ISR Matrix
<p>The N-by-4 @c Q_ISR matrix stores QS records pertaining to interrupt entry and exit. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Interrupt@n Nesting</th>
    <th>ISR@n Priority</th>
    <th>Nesting@n Delta</th>
  </tr>

  <tr>
    <td>@c #QS_QF_ISR_ENTRY</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ISR_EXIT</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>-1</td>
  </tr>
</table>
</center>

The cumulative sum over the 'Delta' column indicates interrupt nesting level and should closely follow column 2.

The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_ISR matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_QF_ISR_ENTRY</td>
    <td>`Q_ISR(:,4) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_QF_ISR_EXIT</td>
    <td>`Q_ISR(:,4) &lt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_MUTEX Q_MUTEX Matrix
<p>The N-by-4 @c Q_MUTEX matrix stores QS records pertaining to the priority-ceiling mutex activity in QK. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Original@n Priority</th>
    <th>Priority@n Ceiling</th>
    <th>Nesting@n Delta</th>
  </tr>

  <tr>
    <td>@c #QS_MUTEX_LOCK</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>+1</td>
  </tr>

  <tr>
    <td>@c #QS_MUTEX_UNLOCK</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
    <td>-1</td>
  </tr>
</table>
</center>


The cumulative sum over the 'Delta' column indicates QK scheduler lock nesting level.

@image html FigQSPY.05.jpg "Plot stairs(Q_MUTEX(:,1), cumsum(Q_MUTEX(:,4)), 'r') (red)"


The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_ISR matrix:

<center>
<table>
  <tr>
    <th>QS Record</th>
    <th>MATLAB Index Matrix</th>
  </tr>

  <tr>
    <td>@c #QS_MUTEX_LOCK</td>
    <td>`Q_MUTEX(:,4) &gt; 0`</td>
  </tr>

  <tr>
    <td>@c #QS_MUTEX_UNLOCK</td>
    <td>`Q_MUTEX(:,4) &lt; 0`</td>
  </tr>
</table>
</center>


@section MATLAB_Q_SCHED Q_SCHED Matrix
<p>The N-by-3 @c Q_SCHED matrix stores QS records pertaining to scheduling next task in QK. The following table summarizes how the QS records are stored in the matrix:
</p>

<center>
<table>
  <tr>
    <th>&nbsp;MATLAB index --&gt;</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
  </tr>

  <tr>
    <th>QS Record@n |@n V</th>
    <th>Time@n Stamp</th>
    <th>Preempted@n Priority</th>
    <th>New@n Priority</th>
  </tr>

  <tr>
    <td>@c #QS_SCHED_NEXT</td>
    <td>#</td>
    <td>#</td>
    <td>#</td>
  </tr>
</table>
</center>

@nav{qspy_seq,qutest}
*/
