/*! @page qspy QSPY Host Application

@tableofcontents

@section qspy_about About QSPY
<p>As described in the @ref qspy_system "previous section", **QSPY** is the host-resident component in the QP/Spy software tracing system. QSPY is a simple console application without a GUI, because its main purpose is to provide @ref qspy_link "communication" with the @ref qs "QS target-resident component", parsing of the @ref qpspy_proto "QP/Spy Data Protocol" and displaying the data in a simple @ref qspy_text "human-readable format".
</p>

QSPY can also export the data in various other formats, such as format suitable for @ref qspy_matlab "MATLAB/GNU-Octave", and format suitable for generating message sequence diagrams with @ref qspy_mscgen "MscGen". Additionally, QSPY can also save the symbolic information about the Target objects in form of @ref qspy_dict "QSPY dictionaries". An example of a @ref qpspy_exa "QSPY session" is shown in the Introduction to QP/Spy.

Finally, QSPY supports also extensible @ref qspy_udp "UDP-socket" connection, which allows it to serve as a <em>"Back-End"</em> for attaching various "Front-Ends" (such as the @ref qutest "QUTest" Front-End and @ref qspyview "QSpyView" Front-End).

@remark
QSPY is written in portable C with ports to Windows and POSIX (Linux, macOS) provided. QSPY is also designed to be adaptable to various target-host communication links. Out of the box, the QSPY host application supports serial (RS232), TCP/IP, and file communication links. Adding other communication links is straightforward, because the data link is accessed only through a generic Platform Abstraction Layer (PAL).


-------------------------------------------------------------------------------
@section qspy_command QSPY Command-Line Parameters
<p>The QSPY application accepts several command-line parameters to configure the data link to the Target, backwards-compatibly with previous versions, and target dependencies, such as pointer sizes, signal sizes, etc. This means that the single QSPY host application can process data from any Target running the QS component. QSPY has been tested with wide range of 8-, 16-, 32-, and 64-bit CPUs.
</p>

The general form of invoking QSPY is as follows:

@verbatim
qspy [options]
@endverbatim

where `options` are described in the following table:

@verbatim
Usage: qspy [options]     <arg> = required, [arg] = optional
@endverbatim

<TABLE SUMMARY="QSPY options" cellSpacing=4 cellPadding=1 border=0
ALIGN="center" VALIGN="middle">
  <TR bgColor="#c8cedc">
    <TD><B>&nbsp;Option</B></TD>
    <TD><B>&nbsp;Example</B></TD>
    <TD><B>&nbsp;Default@n (key)</B></TD>
    <TD><B>&nbsp;Must match QP macro@n (QP port header file)</B></TD>
    <TD><B>&nbsp;Comments</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-h</TD>
    <TD>-h</TD>
    <TD></TD>
    <TD></TD>
    <TD>Help. Prints the summary of options</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-q [num]</TD>
    <TD>-q 99</TD>
    <TD>(key-q)</TD>
    <TD></TD>
    <TD>Quiet mode (reduced stdout output)</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-u [UDP_port]</TD>
    <TD>-u</TD>
    <TD>7701</TD>
    <TD></TD>
    <TD>UDP socket for "Front-Ends"</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-v &lt;QS_version&gt;</TD>
    <TD>-v 5.0</TD>
    <TD>6.0</TD>
    <TD></TD>
    <TD>Compatility with QS version</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-o</TD>
    <TD>-o</TD>
    <TD>(key-o)</TD>
    <TD></TD>
    <TD>Produce output to the specified file</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-s</TD>
    <TD>-s</TD>
    <TD>(key-s)</TD>
    <TD></TD>
    <TD>Save the binary input to a file. Not compatible with -f
    </TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-m</TD>
    <TD>-m</TD>
    <TD>(key-m)</TD>
    <TD></TD>
    <TD>Produce @ref qspy_matlab "MATLAB/GNU-Octave output" to a file</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-g</TD>
    <TD>-g</TD>
    <TD>(key-g)</TD>
    <TD></TD>
    <TD>Produce @ref qspy_mscgen "MscGen output" to a file</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-c &lt;port&gt;</TD>
    <TD>-c COM2</TD>
    <TD>COM1</TD>
    <TD></TD>
    <TD>COM port selection. Not compatible with -t, -p, -f</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-b &lt;baud&gt;</TD>
    <TD>-b 38400</TD>
    <TD>115200</TD>
    <TD></TD>
    <TD>Baud rate selection. Not compatible with -t, -p, -f</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-t [TCP-port]</TD>
    <TD>-t </TD>
    <TD>6601</TD>
    <TD></TD>
    <TD>TCP/IP input selection. Not compatible with -c, -b, -f</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-f &lt;file&gt;</TD>
    <TD>-f qs.spy</TD>
    <TD></TD>
    <TD></TD>
    <TD>File input selection. Not compatible with -c, -b, -t, -p</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-d [file]</TD>
    <TD>-d qspy150831_144229.dic</TD>
    <TD></TD>
    <TD></TD>
    <TD>Read @ref qspy_dict "dictionaries" from a file.</TD>
  </TR>

  <TR bgColor="#f0f0c0">
    <TD colspan="5"><strong>Options for configuring Target object sizes:</strong>@n
The Target can **report** it's configuration to QSPY, which means that you don't need to provide any upper-case options (such as: `-T`, `-O`, `-F`, etc.).
    </TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-T &lt;size&gt;</TD>
    <TD>-T 2</TD>
    <TD>4</TD>
    <TD>@c QS_TIME_SIZE @n (qs_port.h)</TD>
    <TD>Time stamp size in bytes. Valid values: 1, 2, 4</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-O &lt;size&gt;</TD>
    <TD>-O 2</TD>
    <TD>4</TD>
    <TD>@c QS_OBJ_PTR_SIZE @n (qs_port.h)</TD>
    <TD>Object pointer size in bytes. Valid values: 1, 2, 4, 8</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-F &lt;size&gt;</TD>
    <TD>-F 2</TD>
    <TD>4</TD>
    <TD>@c QS_FUN_PTR_SIZE @n (qs_port.h)</TD>
    <TD>Function pointer size in bytes. Valid values: 1, 2, 4, 8</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-S &lt;size&gt;</TD>
    <TD>-S 1</TD>
    <TD>2</TD>
    <TD>@c Q_SIGNAL_SIZE @n (qep_port.h)</TD>
    <TD>Signal size in bytes. Valid values: 1, 2, 4</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-E &lt;size&gt;</TD>
    <TD>-E 1</TD>
    <TD>2</TD>
    <TD>@c QF_EVENT_SIZ_SIZE @n (qf_port.h)</TD>
    <TD>Event-size size in bytes (i.e., the size of variables that hold
        event size). Valid values: 1, 2, 4</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-Q &lt;size&gt;</TD>
    <TD>-Q 2</TD>
    <TD>1</TD>
    <TD>@c QF_EQUEUE_CTR_SIZE @n (qf_port.h)</TD>
    <TD>Queue counter size in bytes. Valid values 1, 2, 4</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-P &lt;size&gt;</TD>
    <TD>-P 4</TD>
    <TD>2</TD>
    <TD>@c QF_MPOOL_CTR_SIZE @n (qf_port.h)</TD>
    <TD>Pool counter size in bytes. Valid values: 1, 2, 4</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>-B &lt;size&gt;</TD>
    <TD>-B 1</TD>
    <TD>2</TD>
    <TD>@c QF_MPOOL_SIZ_SIZE @n (qf_port.h)</TD>
    <TD>Block size size in bytes. (i.e., the size of variables that hold
        memory block size). Valid values 1, 2, 4</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>-C &lt;size&gt;</TD>
    <TD>-C 4</TD>
    <TD>2</TD>
    <TD>@c QF_TIMEEVT_CTR_SIZE @n (qf_port.h)</TD>
    <TD>Time event counter size. Valid values: 1, 2, 4</TD>
  </TR>
</TABLE>


Your main concern when invoking QSPY is to match exactly the target system you
are using. The fourth column of the table above lists the configuration macros
used by the target system as well as the platform-specific QP header files
where those macros are defined. You need to use the corresponding QSPY
command-line option only when the QP macro differs from the default. The
default values assumed by QSPY are consistent with the defaults used in QP.

@note
When you do not match the QSPY host application with the QS target
component, the QSPY application will be unable to parse correctly the
mismatched trace records and will start generating the following errors:@n
@n
@verbatim
   ~ ~ ~
   <COMMS> ERROR    4 bytes unused in Rec=QS_QEP_INTERN_TRAN
   ~ ~ ~
   <COMMS> ERROR    2 bytes unused in Rec=QS_QEP_DISPATCH
@endverbatim
@n
The name after `Rec=` indicates the <a href="qs__copy_8h.html#acdb495c1e5524b5d95aaff82c47f6db5"><strong>Record ID</strong></a> of the trace record that failed to be parsed.


-------------------------------------------------------------------------------
@section qspy_keyboard QSPY Keyboard Commands
The QSPY console application accepts keyboard input. The following table shows the currently supported key-strokes:


Key | Action
----|---------
`&lt;Esc&gt;` | Exit QSPY
`h`     | display keyboard help and QSPY status
`c`     | clear the screen
`q`     | toggle quite mode (no Target output to the screen)
`r`     | send RESET command to the Target
`i`     | send the INFO request to the Target (see also @ref qspy_dict)
`t`     | send TIKC[0] command to the Target
`u`     | send TICK[1] command to the Target
`d`     | save @ref qspy_dict "QP/Spy Dictionaries" to a file
`o`     | toggle @ref qspy_text "QSPY Human-Readable Output" to a file (open/close)
`s`/`b` | toggle binary file output (open/close)
`m`     | toggle @ref qspy_matlab "MATLAB Output" to a file (open/close)
`g`     | toggle @ref qspy_mscgen "MscGen Output" to a file (open/close)


@note
QSPY can send many more sophisticated commands to the Target by means of the @ref qspyview "Front-End extension mechanism".


-------------------------------------------------------------------------------
@section qspy_link QSPY Communication with the Target
QSPY currently provides the following communication links to the @ref qs "QS target-resident component":


Communication Link | Command-Line Option
:------------------|:--------------------
Serial port        | `-c<COM_port>` and `-b<baud_rate>`
Binaly File        | `-f<file_name>`
TCP/IP             | `-t[TCP_port]`
Other link@n(e.g., JTAG debug probe) | can be added to the QSPY Platform Abstraction Layer


-------------------------------------------------------------------------------
@section qspy_saving Saving Files from QSPY

QSPY can save the tracing data from the Target in various formats into files. QSPY assigns file names **automatically**. Also, QSPY can open/close various files multiple times in a single session, so it is no longer necessary to exit QSPY and launch it again with different command-line parameters to save data to a different file.

@attention
QSPY saves all files into the <strong>current directory</strong> from which `qspy` has been launched.

QSPY uses a very simple naming convention to assign file names. All names start with `qspy<time-stamp>`, where the  time-stamp format is: `YYMMDD_hhmmss`, where `YY` is 2-digit year, `MM` is a 2-digit month, `DD` is a 2-digit day of the month, `hh` is a 2-digit hour, `mm` is a 2-digit minute, and `ss` is a 2-digit second. The time-stamp is accurate to a one second, so its virtually impossible to have name conflicts for files generated on the same machine. The various types of files are distinguished by the following extensions:

Command-Line@n Option | Keyboard@n Option| File@n Extension |  Example |  Comment
:-------------------:|:-----------------:|:----------------:|----------|----------
`-o`                | `o`            | `.txt`    | `qspy150914_132234.txt`| @ref qspy_text "text (screen) output"
`-s`                | `s`            | `.qs`     | `qspy150914_132234.qs`  | @ref qpspy_proto "raw binary output"
`-d`                | `d`            | `.dic`    | `qspy150901_101203.dic` | @ref qspy_dict "dictionary output"
`-m`                | `m`            | `.mat`    | `qspy150914_132234.mat` | @ref qspy_matlab "MATLAB output"
`-g`                | `g`            | `.msc`    | `qspy150914_132234.msg` | @ref qspy_mscgen "MscGen output"

@note
All files except the dictionary output are time-stamped with the <strong>local</strong> time of the Host. The **dictionary** output is time-stamped with the build-time of the Target image.


------------------------------------------------------------------------------
The following sub-sections explain the following QSPY features:

- @subpage qspy_text "text (screen) output"
- @subpage qspy_dict "dictionary output"
- @subpage qspy_udp  "UDP socket interface"
- @subpage qspy_matlab "MATLAB output"
- @subpage qspy_mscgen "MscGen output"

@next{qspy_text}
*/
/*###########################################################################*/
/**
@page qspy_text QSPY Screen Output

@tableofcontents

<p>QSPY provides a simple consolidated, human-readable textual output to the screen. The readability of this output depends strongly on the availability of the <em>symbolic information</em> about the various objects in the Target code, called @ref qspy_dict "dictionaries". If the "dictionaries" are not available, QSPY can output only the hexadecimal values of various object addresses and event signals. However, if QSPY has acquired the @ref qs_dict "dictionaries" from the Target, or has @ref qspy_dict_read "read them from a file", it can apply the symbolic information to output the provided identifiers for objects, signals, and states.
</p>

@note
In the process of adapting QSPY for supporting @ref qutest "QUTest Unit Testing", the QSPY human-redable output has been changed to avoid any special characters used in regular expressions, such as `*, [, ], ?, !`. This is because the QUTest scripts use regular expressions to match QSPY textuall output with the expected output.


-------------------------------------------------------------------------------
@section qspy_text_exa Screen Output Example
For example, the following listing shows the QSPY text output when the @ref qs_dict "dictionaries" **are** available:

@verbatim
C:\qp\qpc\examples\arm-cm\dpp_efm32-slstk3401a\qxk\gnu>qspy -cCOM6
QSPY host utility 5.9.0
Copyright (c) 2005-2017 Quantum Leaps (state-machine.com)
Time Stamp: 170519_115355
-cCOM6
-v590
-T4
-O4
-F4
-S2
-E2
-Q1
-P2
-B2
-C2

########## Trg-RST  QP-Ver=590,Build=170519_093948
           Obj-Dict 0x000055A6->QS_RX
           Obj-Dict 0x000051F2->l_SysTick_Handler
           Obj-Dict 0x000051F1->l_GPIO_EVEN_IRQHandler
           Usr-Dict 00000070->PHILO_STAT
           Usr-Dict 00000071->PAUSED_STAT
           Usr-Dict 00000072->COMMAND_STAT
           Obj-Dict 0x20000D40->smlPoolSto
           Obj-Dict 0x20000DB4->tableQueueSto
. . . . .
           Obj-Dict 0x200012F8->l_philo<4>
           Obj-Dict 0x20001328->l_philo<4>.timeEvt
           Fun-Dict 0x00000B8D->Philo_initial
           Fun-Dict 0x00000DD5->Philo_thinking
. . . . .
           Sig-Dict 00000010,Obj=0x200011F8->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x200011F8->TIMEOUT_SIG
===RTC===> St-Init  Obj=l_philo<0>,State=0x00001B05->Philo_thinking
===RTC===> St-Entry Obj=l_philo<0>,State=Philo_thinking
0000190000 Init===> Obj=l_philo<0>,State=Philo_thinking
           Sig-Dict 00000010,Obj=0x20001238->HUNGRY_SIG
. . . . .
===RTC===> St-Init  Obj=l_philo<4>,State=0x00001B05->Philo_thinking
===RTC===> St-Entry Obj=l_philo<4>,State=Philo_thinking
0000190000 Init===> Obj=l_philo<4>,State=Philo_thinking
           Obj-Dict 0x2000133C->l_table
           Fun-Dict 0x00001B05->QHsm_top
. . . . .
           Sig-Dict 00000010,Obj=0x2000133C->HUNGRY_SIG
0000190000 PHILO_STAT 0 thinking
0000190000 PHILO_STAT 1 thinking
0000190000 PHILO_STAT 2 thinking
0000190000 PHILO_STAT 3 thinking
0000190000 PHILO_STAT 4 thinking
===RTC===> St-Init  Obj=l_table,State=QHsm_top->Table_serving
===RTC===> St-Entry Obj=l_table,State=Table_serving
0000190000 Init===> Obj=l_table,State=Table_serving
0000380805 Disp===> Obj=l_table,Sig=SERVE_SIG,State=Table_serving
0000381523 =>Ignore Obj=l_table,Sig=SERVE_SIG,State=Table_serving
0009691003 Disp===> Obj=l_philo<4>,Sig=TIMEOUT_SIG,State=Philo_thinking
===RTC===> St-Exit  Obj=l_philo<4>,State=Philo_thinking
0009692721 Disp===> Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
0009693389 PHILO_STAT 4 hungry
0009695383 PHILO_STAT 4 eating
0009695932 =>Intern Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
===RTC===> St-Entry Obj=l_philo<4>,State=Philo_hungry
0009697188 ===>Tran Obj=l_philo<4>,Sig=TIMEOUT_SIG,State=Philo_thinking->Philo_hungry
0009698052 Disp===> Obj=l_philo<4>,Sig=EAT_SIG,State=Philo_hungry
===RTC===> St-Entry Obj=l_philo<4>,State=Philo_eating
0009699697 ===>Tran Obj=l_philo<4>,Sig=EAT_SIG,State=Philo_hungry->Philo_eating
0009700602 Disp===> Obj=l_philo<3>,Sig=EAT_SIG,State=Philo_thinking
0009701247 =>Intern Obj=l_philo<3>,Sig=EAT_SIG,State=Philo_thinking
. . . . . .
@endverbatim

The QS trace log shown in the listing above contains quite detailed information, because most QS records are enabled (are not blocked in the @ref "QS filters"). The following bullet items highlight the most interesting parts of the trace and illustrate how you can interpret the trace data:

- The QS output starts with the QSPY application version number, the date and time of the run (run time-stamp), and all the options explicitly provided to the QSPY host application.

- The first trace records in the log are typically @ref qspy_dict "dictionary trace records" that provide a mapping between addresses of various objects in memory and their symbolic names.

- After the dictionaries, you see the active object initialization. For example, the `===RTC===> St-Init` record indicates that the top-most initial transition in the active object `l_table` has been taken. After this, the `===RTC===> St-Entry` record informs you that the state `Table_serving` has been entered, and finally the record `==>Init` tells you that the top-most initial transition sequence has completed. This trace record has a high-resolution @qs_tstamp "time-stamp" (the first 10-digit number) generated by the Target. The time units used by this time-stamp depend on the specific hardware timer used in the Target, but typically it is sub-microsecond.

- After this you see that at the time-stamp `0000380805` an event was dispatched (`Disp===>` record) to `l_table`, but it was subsequently `Ignored`, while `l_table` was in the state `Table_serving`.


-------------------------------------------------------------------------------
@section qspy_pre Predefined Trace Records
The following table summarizes the text output format used for all predefined QS trace records (see ::QSpyRecords).

@note
To better adapt QSPY to support @ref qutest "QUTest Unit Testing", the QSPY human-redable output has been changed at @ref qtools_5_9_0 "version 5.9.0" to avoid any special characters used in regular expressions, such as `*, [, ], ?, !`. This is because the QUTest scripts use regular expressions to match QSPY textuall output with the expected output.


<TABLE SUMMARY="QEP Records" cellSpacing=4 cellPadding=1 border=0 width="99%">

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>State Machine Trace Records (QEP)</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>1</TD>
    <TD>#QS_QEP_STATE_ENTRY</TD>
    <TD>`===RTC===> St-Entry`</TD>
    <TD>a state was entered</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>2</TD>
    <TD>#QS_QEP_STATE_EXIT</TD>
    <TD>`===RTC===> St-Exit`</TD>
    <TD>a state was exited</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>3</TD>
    <TD>#QS_QEP_STATE_INIT</TD>
    <TD>`<timestamp> St-Init`</TD>
    <TD>an initial transition was taken in a state</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>4</TD>
    <TD>#QS_QEP_INIT_TRAN</TD>
    <TD>`<timestamp> Init===>`</TD>
    <TD>the top-most initial transition was taken</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>5</TD>
    <TD>#QS_QEP_INTERN_TRAN</TD>
    <TD>`<timestamp> =>Intern`</TD>
    <TD>an internal transition was taken</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>6</TD>
    <TD>#QS_QEP_TRAN</TD>
    <TD>`<timestamp> ===>Tran `</TD>
    <TD>a regular transition was taken</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>7</TD>
    <TD>#QS_QEP_IGNORED</TD>
    <TD>`<timestamp> =>Ignore`</TD>
    <TD>an event was ignored (silently discarded)</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>8</TD>
    <TD>#QS_QEP_DISPATCH</TD>
    <TD>`<timestamp> Disp===>`</TD>
    <TD>an event was dispatched (begin of RTC step)</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>9</TD>
    <TD>#QS_QEP_UNHANDLED</TD>
    <TD>`===RTC===> St-Unhnd`</TD>
    <TD>a guard prevented handling of an event</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>55</TD>
    <TD>#QS_QEP_TRAN_HIST</TD>
    <TD>`===RTC===> St-Hist`</TD>
    <TD>an a transition to history was taken </TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>56</TD>
    <TD>#QS_QEP_TRAN_EP</TD>
    <TD>`===RTC===> St-EP`</TD>
    <TD>an a transition to entry point into a submachine </TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>57</TD>
    <TD>#QS_QEP_TRAN_XP</TD>
    <TD>`===RTC===> St-XP`</TD>
    <TD>an a transition to exit  point out of a submachine </TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>Active Object Trace Records</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>10</TD>
    <TD>#QS_QF_ACTIVE_ADD</TD>
    <TD>`<timestamp> AO-Add`</TD>
    <TD>an AO has been added to QF (started)</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>11</TD>
    <TD>#QS_QF_ACTIVE_REMOVE</TD>
    <TD>`<timestamp> AO-Remov`</TD>
    <TD>an AO has been removed from QF (stopped)</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>12</TD>
    <TD>#QS_QF_ACTIVE_SUBSCRIBE</TD>
    <TD>`<timestamp> AO-Subsc`</TD>
    <TD>an AO subscribed to an event</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>13</TD>
    <TD>#QS_QF_ACTIVE_UNSUBSCRIBE</TD>
    <TD>`<timestamp> AO-Unsub`</TD>
    <TD>an AO unsubscribed to an event</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>14</TD>
    <TD>#QS_QF_ACTIVE_POST_FIFO</TD>
    <TD>`<timestamp> AO-Post`</TD>
    <TD>an event was posted (FIFO) directly to AO</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>15</TD>
    <TD>#QS_QF_ACTIVE_POST_LIFO</TD>
    <TD>`<timestamp> AO-LIFO`</TD>
    <TD>an event was posted (LIFO) directly to AO</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>16</TD>
    <TD>#QS_QF_ACTIVE_GET</TD>
    <TD>`<timestamp> AO-Get`</TD>
    <TD>AO got an event and its queue is still not empty</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>17</TD>
    <TD>#QS_QF_ACTIVE_GET_LAST</TD>
    <TD>`<timestamp> AO-GetL`</TD>
    <TD>AO got an event and its queue is empty</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>45</TD>
    <TD>#QS_QF_ACTIVE_POST_ATTEMPT</TD>
    <TD>`<timestamp> AO-PostA`</TD>
    <TD>attempt to post an evt to AO failed</TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>Raw Event Queue Trace Records</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>18</TD>
    <TD>#QS_QF_EQUEUE_INIT</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQ-Init`</TD>
    <TD>an event queue was initialized</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>19</TD>
    <TD>#QS_QF_EQUEUE_POST_FIFO</TD>
    <TD>`<timestamp> EQ-Post`</TD>
    <TD>an event was posted (FIFO) to a raw queue</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>20</TD>
    <TD>#QS_QF_EQUEUE_POST_LIFO</TD>
    <TD>`<timestamp> EQ-LIFO`</TD>
    <TD>an event was posted (LIFO) to a raw queue</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>21</TD>
    <TD>#QS_QF_EQUEUE_GET</TD>
    <TD>`<timestamp> EQ-Get`</TD>
    <TD>get an event and queue still not empty</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>22</TD>
    <TD>#QS_QF_EQUEUE_GET_LAST</TD>
    <TD>`<timestamp> EQ-GetL`</TD>
    <TD>get the last event from the queue</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>46</TD>
    <TD>#QS_QF_EQUEUE_POST_ATTEMPT</TD>
    <TD>`<timestamp> EQ-PostA`</TD>
    <TD>attempt to post an evt to QEQueue failed</TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>Raw Memory Pool Trace Records</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>23</TD>
    <TD>#QS_QF_MPOOL_INIT</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MP-Init`</TD>
    <TD>a memory pool was initialized</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>24</TD>
    <TD>#QS_QF_MPOOL_GET</TD>
    <TD>`<timestamp> MP-Get`</TD>
    <TD>a memory block was removed from a memory pool</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>24</TD>
    <TD>#QS_QF_MPOOL_GET_ATTEMPT</TD>
    <TD>`<timestamp> MP-GetA`</TD>
    <TD>a memory block was removed from a memory pool</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>25</TD>
    <TD>#QS_QF_MPOOL_PUT</TD>
    <TD>`<timestamp> MP-Put`</TD>
    <TD>a memory block was returned to a memory pool</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>47</TD>
    <TD>#QS_QF_MPOOL_GET_ATTEMPT</TD>
    <TD>`<timestamp> MP-GetA`</TD>
    <TD>attempt to get a memory block failed </TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>Event Management (QF)</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>26</TD>
    <TD>#QS_QF_PUBLISH</TD>
    <TD>`<timestamp> QF-Pub`</TD>
    <TD>an event was published</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>27</TD>
    <TD>RESERVED</TD>
    <TD></TD>
    <TD></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>28</TD>
    <TD>#QS_QF_NEW</TD>
    <TD>`<timestamp> QF-New`</TD>
    <TD>new event creation</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>29</TD>
    <TD>#QS_QF_GC_ATTEMPT</TD>
    <TD>`<timestamp> QF-gcA`</TD>
    <TD>garbage collection attempt</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>30</TD>
    <TD>#QS_QF_GC</TD>
    <TD>`<timestamp> QF-gc`</TD>
    <TD>garbage collection performed</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>31</TD>
    <TD>#QS_QF_TICK</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tick`</TD>
    <TD>QF system clock tick processing was called</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>39</TD>
    <TD>#QS_QF_CRIT_ENTRY</TD>
    <TD>`<timestamp> QF-CritE`</TD>
    <TD>critical section was entered</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>40</TD>
    <TD>#QS_QF_CRIT_EXIT</TD>
    <TD>`<timestamp> QF-CritX`</TD>
    <TD>critical section was exited</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>41</TD>
    <TD>#QS_QF_ISR_ENTRY</TD>
    <TD>`<timestamp> QF-IsrE`</TD>
    <TD>an ISR was entered</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>42</TD>
    <TD>#QS_QF_ISR_EXIT</TD>
    <TD>`<timestamp> QF-IsrX`</TD>
    <TD>an ISR was exited</TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>Time Events (TE)</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>32</TD>
    <TD>#QS_QF_TIMEEVT_ARM</TD>
    <TD>`<timestamp> TE-Arm`</TD>
    <TD>a time event was armed</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>33</TD>
    <TD>#QS_QF_TIMEEVT_AUTO_DISARM</TD>
    <TD>`<timestamp> TE-ADis`</TD>
    <TD>a time event expired and was disarmed</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>34</TD>
    <TD>#QS_QF_TIMEEVT_DISARM_ATTEMPT</TD>
    <TD>`<timestamp> TE-DisA`</TD>
    <TD>attempt to disarmed a disarmed tevent</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>35</TD>
    <TD>#QS_QF_TIMEEVT_DISARM</TD>
    <TD>`<timestamp> TE-Dis`</TD>
    <TD>true disarming of an armed time event</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>36</TD>
    <TD>#QS_QF_TIMEEVT_REARM</TD>
    <TD>`<timestamp> TE-Rarm`</TD>
    <TD>rearming of a time event</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>37</TD>
    <TD>#QS_QF_TIMEEVT_POST</TD>
    <TD>`<timestamp> TE-Post`</TD>
    <TD>a time event posted itself directly to an AO</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>38</TD>
    <TD>#QS_QF_TIMEEVT_CTR</TD>
    <TD>`<timestamp> TE-Ctr`</TD>
    <TD>a time event counter was requested </TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>Scheduler Trace Records</strong></TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>50</TD>
    <TD>#QS_SCHED_LOCK</TD>
    <TD>`<timestamp> Sch-Lock`</TD>
    <TD>scheduler was locked</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>51</TD>
    <TD>#QS_SCHED_UNLOCK</TD>
    <TD>`<timestamp> Sch-Unlk`</TD>
    <TD>scheduler was unlocked</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>52</TD>
    <TD>#QS_SCHED_NEXT</TD>
    <TD>`<timestamp> Sch-Next`</TD>
    <TD>scheduler found next task to execute</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>53</TD>
    <TD>#QS_SCHED_IDLE</TD>
    <TD>`<timestamp> Sch-Idle`</TD>
    <TD>scheduler became idle</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>54</TD>
    <TD>#QS_SCHED_RESUME</TD>
    <TD>`<timestamp> Sch-Rsme`</TD>
    <TD>scheduler resumed previous task (not idle)</TD>
  </TR>

  <TR bgColor="#f07070">
      <TD colspan="4"><strong>Miscellaneous Trace Records@n
      NOT MASKABLE WITH THE @ref qs_global "QS GLOBAL FILTER"!
      </strong>
      </TD>
  </TR>

  <TR bgColor="#c8cedc">
    <TD><B>Rec.@n Num.</B></TD>
    <TD><B>Rec.@n Enum.</B></TD>
    <TD><B>Start of record</B></TD>
    <TD><B>Comment</B></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>58</TD>
    <TD>#QS_TEST_PAUSED</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TstPause`</TD>
    <TD>test has been paused</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>59</TD>
    <TD>#QS_TEST_PROBE_GET</TD>
    <TD>`<timestamp> TstProbe`</TD>
    <TD>reports that Test-Probe has been used</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>60</TD>
    <TD>#QS_SIG_DICTIONARY</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sig-Dict`</TD>
    <TD>signal dictionary entry</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>61</TD>
    <TD>#QS_OBJ_DICTIONARY</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Obj-Dict`</TD>
    <TD>object dictionary entry</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>62</TD>
    <TD>#QS_FUN_DICTIONARY</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fun-Dict`</TD>
    <TD>function dictionary entry</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>63</TD>
    <TD>#QS_USR_DICTIONARY</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usr-Dict`</TD>
    <TD>User record dictionary entry</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>64</TD>
    <TD>#QS_TARGET_INFO</TD>
    <TD>`########## Trg-Info`</TD>
    <TD>reports the Target information</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>65</TD>
    <TD>#QS_TARGET_DONE</TD>
    <TD>`<timestamp> Trg-Done`</TD>
    <TD>reports completion of a user callback</TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>66</TD>
    <TD>#QS_RX_STATUS</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trg-Ack`</TD>
    <TD>reports QS data receive status</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>66</TD>
    <TD>RESERVED</TD>
    <TD></TD>
    <TD></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>66</TD>
    <TD>#QS_PEEK_DATA</TD>
    <TD>`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trg-Peek`</TD>
    <TD>reports the data from the PEEK query</TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>67</TD>
    <TD>#QS_ASSERT_FAIL</TD>
    <TD>`<timestamp> =ASSERT=`</TD>
    <TD>Assertion fired</TD>
  </TR>

  <TR bgColor="#f0f0c0">
      <TD colspan="4"><strong>User (Application Specific) Records</strong></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>70</TD>
    <TD>#QS_USER + xxx</TD>
    <TD>`<timestamp> USER+xxx`</TD>
    <TD>@ref qs_app "application-specific" (user) QS records</TD>
  </TR>
</TABLE>

@next{qspy_dict}
*/
/*###########################################################################*/
/**
@page qspy_dict QSPY Dictionaries

@tableofcontents

@section qspy_dict_about About QSPY Dictionaries
By the time you compile and load your application image to the Target, the symbolic names of various objects, function names, and event signal names are stripped from the code. Therefore, if you want to have the symbolic information available to the QSPY host-resident component, you need to supply it somehow to the software tracing system.

The QS Target-resident component provides special @ref qs_dict "dictionary trace records" designed expressly for providing the symbolic information about the target code in the trace itself. These "dictionary records" are very much like the symbolic information embedded in the object files for the traditional single-step debugger. QS can supply four types of dictionary trace records:

- object dictionary -- for identifying objects (HSMs, AOs, Time events, etc)
- function dictionary -- for identifying functions (state-handlers)
- signal dictionary -- for identifying event signals
- user dictionary -- for identifying @ref qs_app "application-specific" (user) records

@note
QSPY does not absolutely require the presence of dictionary trace records to generate the human-readable output, in the same way as the symbolic information in the object files is not absolutely required to debug code. However, in both cases, the availability of the symbolic information greatly improves the readability of the disassembly code shown in the debugger.


For instance, the following listing shows an example of the QSPY text output when the "dictionaries" are **not** available. (<b>NOTE:</b> dictionaries might not be available because (1) the Target does not produce @ref qs_dict "dictionary trace records" for all relevant objects or (2) the Target does produce all dictionaries, but QSPY has never seen them, because it was attached to the Target after the dictionaries have been transmitted):
@n
@verbatim
. . . . . .
0009692721 Disp===> Obj=0x2000133C,Sig=00000010,Obj=0x2000133C,State=0x000010C5
0009693389 USER+000 4 hungry
0009695383 USER+000 4 eating
0009695932 =>Intern Obj=0x2000133C,Sig=00000010,Obj=0x2000133C,State=0x000010C5
===RTC===> St-Entry Obj=0x200012F8,State=0x00000D49
0009697188 ===>Tran Obj=0x200012F8,Sig=00000011,Obj=0x200012F8,State=0x00000DD5->0x00000D49
0009698052 Disp===> Obj=0x200012F8,Sig=00000004,Obj=0x200012F8,State=0x00000D49
===RTC===> St-Entry Obj=0x200012F8,State=0x00000CA9
0009699697 ===>Tran Obj=0x200012F8,Sig=00000004,Obj=0x200012F8,State=0x00000D49->0x00000CA9
0009700602 Disp===> Obj=0x200012B8,Sig=00000004,Obj=0x200012B8,State=0x00000DD5
0009701247 =>Intern Obj=0x200012B8,Sig=00000004,Obj=0x200012B8,State=0x00000DD5
0009702038 Disp===> Obj=0x20001278,Sig=00000004,Obj=0x20001278,State=0x00000DD5
0009702677 =>Intern Obj=0x20001278,Sig=00000004,Obj=0x20001278,State=0x00000DD5
0009703468 Disp===> Obj=0x20001238,Sig=00000004,Obj=0x20001238,State=0x00000DD5
0009704107 =>Intern Obj=0x20001238,Sig=00000004,Obj=0x20001238,State=0x00000DD5
0009704899 Disp===> Obj=0x200011F8,Sig=00000004,Obj=0x200011F8,State=0x00000DD5
0009705538 =>Intern Obj=0x200011F8,Sig=00000004,Obj=0x200011F8,State=0x00000DD5
0015961105 Disp===> Obj=0x200011F8,Sig=00000011,Obj=0x200011F8,State=0x00000DD5
===RTC===> St-Exit  Obj=0x200011F8,State=0x00000DD5
0015962823 Disp===> Obj=0x2000133C,Sig=00000010,Obj=0x2000133C,State=0x000010C5
0015963491 USER+000 0 hungry
. . . . . .
@endverbatim

And here is the exact same trace data when the "dictionaries" **are** available:

@verbatim
. . . . . .
0009692721 Disp===> Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
0009693389 PHILO_STAT 4 hungry
0009695383 PHILO_STAT 4 eating
0009695932 =>Intern Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
===RTC===> St-Entry Obj=l_philo<4>,State=Philo_hungry
0009697188 ===>Tran Obj=l_philo<4>,Sig=TIMEOUT_SIG,State=Philo_thinking->Philo_hungry
0009698052 Disp===> Obj=l_philo<4>,Sig=EAT_SIG,State=Philo_hungry
===RTC===> St-Entry Obj=l_philo<4>,State=Philo_eating
0009699697 ===>Tran Obj=l_philo<4>,Sig=EAT_SIG,State=Philo_hungry->Philo_eating
0009700602 Disp===> Obj=l_philo<3>,Sig=EAT_SIG,State=Philo_thinking
0009701247 =>Intern Obj=l_philo<3>,Sig=EAT_SIG,State=Philo_thinking
0009702038 Disp===> Obj=l_philo<2>,Sig=EAT_SIG,State=Philo_thinking
0009702677 =>Intern Obj=l_philo<2>,Sig=EAT_SIG,State=Philo_thinking
0009703468 Disp===> Obj=l_philo<1>,Sig=EAT_SIG,State=Philo_thinking
0009704107 =>Intern Obj=l_philo<1>,Sig=EAT_SIG,State=Philo_thinking
0009704899 Disp===> Obj=l_philo<0>,Sig=EAT_SIG,State=Philo_thinking
0009705538 =>Intern Obj=l_philo<0>,Sig=EAT_SIG,State=Philo_thinking
0015961105 Disp===> Obj=l_philo<0>,Sig=TIMEOUT_SIG,State=Philo_thinking
===RTC===> St-Exit  Obj=l_philo<0>,State=Philo_thinking
0015962823 Disp===> Obj=l_table,Sig=HUNGRY_SIG,State=Table_serving
0015963491 PHILO_STAT 0 hungry
. . . . . .
@endverbatim

As you can see, the difference in readability is quite dramatic.


-------------------------------------------------------------------------------
@section qspy_dict_get Acquiring Dictionaries
The QS Target-resident component generates the dictionary trace records during the initialization of active objects components in the Target code, that is, typically right after the reset. Consequently, the best way to acquire the dictionaries is to capture the trace when the Target performs the reset. This can be done in a couple of ways:
- Start QSPY **before** the Target resets
- Manually reset the Target while QSPY is running (e.g., press a Reset button on the Target board)
- Send the @ref qspy_keyboard "RESET command" to the Target from QSPY while it is running

Either way, the dictionary records should be produced and acquired by the Target. The following listing shows the dictionary records sent by the DPP example application running on the EFM32-SLSTK3401A board:

@verbatim
C:\qp\qpc\examples\arm-cm\dpp_efm32-slstk3401a\qxk\gnu>qspy -cCOM6
QSPY 6.1.0 Copyright (c) 2005-2018 Quantum Leaps
Documentation: https://www.state-machine.com/qtools/qspy.html
Current timestamp: 180119_195728
-u 7701
-c COM7
-v 600
-T 4
-O 4
-F 4
-S 2
-E 2
-Q 1
-P 2
-B 2
-C 2

########## Trg-RST  QP-Ver=604,Build=180117_155932
           Obj-Dict 0x00007322->QS_RX
           Obj-Dict 0x20000D3C->l_SysTick_Handler
           Obj-Dict 0x20000D3D->l_GPIOPortA_IRQHandler
           Usr-Dict 00000070->PHILO_STAT
           Usr-Dict 00000071->PAUSED_STAT
           Usr-Dict 00000072->COMMAND_STAT
           Obj-Dict 0x200015D0->smlPoolSto
           Obj-Dict 0x20001684->tableQueueSto
           Obj-Dict 0x20001620->philoQueueSto<0>
           Obj-Dict 0x20001634->philoQueueSto<1>
           Obj-Dict 0x20001648->philoQueueSto<2>
           Obj-Dict 0x2000165C->philoQueueSto<3>
           Obj-Dict 0x20001670->philoQueueSto<4>
           Obj-Dict 0x20001AEC->l_philo<0>
           Obj-Dict 0x20001B14->l_philo<0>.m_timeEvt
           Obj-Dict 0x20001B24->l_philo<1>
           Obj-Dict 0x20001B4C->l_philo<1>.m_timeEvt
           Obj-Dict 0x20001B5C->l_philo<2>
           Obj-Dict 0x20001B84->l_philo<2>.m_timeEvt
           Obj-Dict 0x20001B94->l_philo<3>
           Obj-Dict 0x20001BBC->l_philo<3>.m_timeEvt
           Obj-Dict 0x20001BCC->l_philo<4>
           Obj-Dict 0x20001BF4->l_philo<4>.m_timeEvt
           Fun-Dict 0x000026C5->Philo::initial
           Fun-Dict 0x000027E1->Philo::thinking
           Fun-Dict 0x0000287D->Philo::hungry
           Fun-Dict 0x00002925->Philo::eating
           Sig-Dict 00000010,Obj=0x20001AEC->HUNGRY_SIG
           Sig-Dict 00000011,Obj=0x20001AEC->TIMEOUT_SIG
. . .      . . .
           Obj-Dict 0x20001C08->l_table
           Fun-Dict 0x000030CB->QP::QHsm::top
           Fun-Dict 0x00002A79->Table::initial
           Fun-Dict 0x00002B8D->Table::active
           Fun-Dict 0x00002BB9->Table::serving
           Fun-Dict 0x00002E29->Table::paused
           Sig-Dict 00000005,Obj=0x00000000->DONE_SIG
           Sig-Dict 00000004,Obj=0x00000000->EAT_SIG
           Sig-Dict 00000006,Obj=0x00000000->PAUSE_SIG
           Sig-Dict 00000007,Obj=0x00000000->SERVE_SIG
           Sig-Dict 00000008,Obj=0x00000000->TEST_SIG
           Sig-Dict 00000010,Obj=0x20001C08->HUNGRY_SIG
. . .      . . .
@endverbatim

Once QSPY acquires the dictionaries, it keeps them in the memory and applies them to display the data in symbolic form (rather than hex addresses).

@note
The dictionaries do not need to be complete to be useful. QSPY simply applies the symbolic information whenever it can find a match in the dictionaries acquired so far. When a dictionary entry is not available, QSPY displays only hex addresses.


-------------------------------------------------------------------------------
@section qspy_dict_save Saving Dictionaries to a File

QSPY can save the dictionaries acquired thus far into a file. This must be triggered by the user (by means of the `d` @ref qspy_keyboard "keyboard command" or from QSpyView menu "File->Save Dictionaries"), because QSPY does not "know" when the dictionaries are "complete", therefore it cannot know when to save them automatically.

@note
For dictionaries to be saved to a file, the QSPY host application must be lauched with the `-d [file]` @ref qspy_command "command-line option", with of without the optional `[file]` parameter.


On the other hand, QSPY generates automatically the file name for saving dictionaries. This file name has always the form `qspy<target-time-stamp>.dic`, where `<target-time-stamp>` unambiguously identifies the Target build date and time. For example, the Target code last built on August 31, 2015 at 14:42:29 will have the name `qspy150831_144229.dic`.

@attention
The internal addresses of objects can change by every code re-build, so dictionaries are applicable only to the specific Target build and must be freshly re-acquired after every new Target code build.

The dictionaries are saved to a file in ASCII format. The following listing shows the dictionaries from the DPP example application running on the EK-TM4C123GXL board:

@verbatim
-v604
-T4
-O4
-F4
-S2
-E2
-Q1
-P2
-B2
-C2
-t180117_155932
Obj-Dic:
21 4
0x00007322 QS_RX
0x20000D3C l_SysTick_Handler
0x20000D3D l_GPIOPortA_IRQHandler
0x200015D0 smlPoolSto
0x20001620 philoQueueSto<0>
0x20001634 philoQueueSto<1>
0x20001648 philoQueueSto<2>
0x2000165C philoQueueSto<3>
0x20001670 philoQueueSto<4>
0x20001684 tableQueueSto
0x20001AEC l_philo<0>
0x20001B14 l_philo<0>.m_timeEvt
0x20001B24 l_philo<1>
0x20001B4C l_philo<1>.m_timeEvt
0x20001B5C l_philo<2>
0x20001B84 l_philo<2>.m_timeEvt
0x20001B94 l_philo<3>
0x20001BBC l_philo<3>.m_timeEvt
0x20001BCC l_philo<4>
0x20001BF4 l_philo<4>.m_timeEvt
0x20001C08 l_table
Fun-Dic:
9 4
0x000026C5 Philo::initial
0x000027E1 Philo::thinking
0x0000287D Philo::hungry
0x00002925 Philo::eating
0x00002A79 Table::initial
0x00002B8D Table::active
0x00002BB9 Table::serving
0x00002E29 Table::paused
0x000030CB QP::QHsm::top
Usr-Dic:
3 1
0x00000046 PHILO_STAT
0x00000047 PAUSED_STAT
0x00000048 COMMAND_STAT
Sig-Dic:
16 4
00000004 0x00000000 EAT_SIG
00000005 0x00000000 DONE_SIG
00000006 0x00000000 PAUSE_SIG
00000007 0x00000000 SERVE_SIG
00000008 0x00000000 TEST_SIG
00000010 0x20001B5C HUNGRY_SIG
00000010 0x20001BCC HUNGRY_SIG
00000010 0x20001B94 HUNGRY_SIG
00000010 0x20001AEC HUNGRY_SIG
00000010 0x20001B24 HUNGRY_SIG
00000010 0x20001C08 HUNGRY_SIG
00000011 0x20001B94 TIMEOUT_SIG
00000011 0x20001BCC TIMEOUT_SIG
00000011 0x20001B5C TIMEOUT_SIG
00000011 0x20001AEC TIMEOUT_SIG
00000011 0x20001B24 TIMEOUT_SIG
Msc-Dic:
0 4
@endverbatim


-------------------------------------------------------------------------------
@section qspy_dict_use Using Dictionary File
The dictionary file saved in previous QSPY sessions can be used in two ways:

- you can specify the dictionary file in the `-d <dictionary_file>` @ref qspy_command "command-line option" to QSPY. In this case QSPY reads the dictionaries from the provided `<dictionary_file>` before processing any trace records from the Target. (**NOTE:** in this case you don't need to provide any of the upper-case command-line options, because they are read from the dictionary file.) For example: command line: `qspy -d qspy180117_155932.dic` will attempt to read the dictionaries from the specified file.

- you can specify the dictionary option without the dictionary file `-d` @ref qspy_command "command-line option" to QSPY. Subsequently, once you run QSPY, you can query the Target information (by means of the `i` or `r` @ref qspy_keyboard "keyboard command" or from QSpyView menu "Commands->Query Target Info"). When the Target replies and provides its build-time-stamp, QSPY looks for the corresponding dictionary file in the current directory and if such a file is found, QSPY reads the dictionaries from it. (**NOTE:** this option requires that the Target implements the QS receive channel, QS-RX, so that it can receive commands from QSPY).

@next{qspy_udp}
*/
/*##########################################################################*/
/**
@page qspy_udp QSPY UDP Interface

@tableofcontents

<p>This section describes the structure of the UDP packets exchanged between the QSPY Back-End and the various front-ends, such as @ref qutest "QUTest" and @ref qspyview "QSpyView"  (<span style="color:blue"><strong>blue arrows</strong></span> in the sequence diagram below). The UDP interface is implemented in the <span class="img file_tcl">qspy.tcl</span> script.
</p>

@image html qspy_comm.gif "Communication between Target, QSPY, and QSpyView"
@n

@note
For better readability, the <span class="img file_tcl">qspy.tcl</span> script uses a convention in which UDP packets to and from the Target (<span style="color:red"><strong>red arrows</strong></span>) are called **Records**, while the word **Packets** is used for communication to and from the QSPY Back-End (<span style="color:blue"><strong>blue arrows</strong></span>). For consistency, the following sections apply the same naming convention: Records for Target communication and Packets for QSPY communication.


------------------------------------------------------------------------------
@section udp_top General UDP Packet Structure

@image html qspy_udp.gif "UDP packet structure"

The UDP packets exchanged between the QSPY Back-End and the `QSpyView` Front-End consists of:

- 1-byte **Sequence-No**, which increments by 1 for every packet and wraps naturally from 0xFF to 0. The sequence number allows `QSpyView` to detect any data discontinuities.

- 1-byte **Record-ID**. The Record-IDs are divided into two categories:
    - Records to and from the Target have Record-IDs in the range <strong>0..127</strong>. Specifically, QS records originated from the Target are enumerated in ::QSpyRecords. Records destined to the Target are enumerated in ::QSpyRxRecords.
    - Records to and from the QSPY Back-End have record-IDs in the range <strong>128..255</strong>. Specifically, records destined to QSPY are enumerated in ::QSpyCommands.

- optional **Data Payload**, which can be either text or binary, depending on the @ref udp_channel "UDP Channel" to which the front-end attaches. The various Data Payloads for different packets are described in the separate sections below.


<div class="separate"></div>
@subsection udp_channel UDP Data Channels
The QSPY UDP socket supports two "channels":
- **binary channel** (channel 1), in which the *Data Payload* is sent in binary, but after removing @ref qspy_transparent "escaping" and checksum;
- **text channel** (channel 2), in which the *Data Payload* is sent in the @ref qspy_text "QSPY Textual Format";

A Front-End can choose the "data channels" when "attaching" to the QSPY host application (see qspy::attach()). The data channels are not exclusive, meaning that a front-end can "attach" simultaneously to both binary and text channels. In this case, the front-end would receive each packet as both binary and text formats.

@remark
The binary-channel (1) is used by the @ref qspyview "QSpyView" GUI front-end, while the text-channel (2) is used by the @ref qutest "QUTest" Unit Testing front-end.


<div class="separate"></div>
@subsection udp_sendPkt Programming Interface
The <span class="img file_tcl">qspy.tcl</span> script provides the Tcl procedure `::qspy::sendPkt` for sending a UDP packet to the QSPY Back-End. The procedure takes one parameter `pkt`, which contains the Record-ID byte followed by the optional Data Payload. For example, here is how to send a packet to @ref udp_AO_FILTER for Active Object with priority 5:

@code
::qspy::sendPkt [binary format cc $::qspy::QS_RX(AO_FILTER) 5]
@endcode


------------------------------------------------------------------------------
@section udp_Target Records to the Target

@note
To understand the following detailed UDP packet descriptions, it is highly recommended to read the Tcl documentation for the <a href="http://www.tcl.tk/man/tcl8.4/TclCmd/binary.htm" target="_blank" class="extern"><strong>binary Tcl command</strong></a>.



<div class="separate"></div>
@subsection udp_INFO  Query Target Info (INFO)
This packet has Record-ID==INFO and has no Data Payload.

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format c $::qspy::QS_RX(INFO)]
@endcode


<div class="separate"></div>
@subsection udp_COMMAND Execute a User-Defined Command in the Target (COMMAND)
This packet has Record-ID==COMMAND and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Command-ID |    c          | command number
Command-Par|    i          | command parameter


<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format cci $::qspy::QS_RX(COMMAND) 12 0x11223344]
@endcode


<div class="separate"></div>
@subsection udp_RESET  Reset the Target (RESET)
This packet has Record-ID==RESET and has no Data Payload.

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format c $::qspy::QS_RX(RESET)]
@endcode


<div class="separate"></div>
@subsection udp_TICK  Call QF_TICK_X() in the Target (TICK)

Data item  | binary format | description
-----------|---------------|-------------
Tick-rate  |    c          | system tick rate number

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format cc $::qspy::QS_RX(TICK) 0]
@endcode


<div class="separate"></div>
@subsection udp_PEEK  Peek Target Memory (PEEK)
This packet has Record-ID==PEEK and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Peek-addr  | Target-dependent@n Typically i | Address of the data in the Target
Peek-length| c             | Number of bytes to peek

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format c$::qspy::theFmt(objPtr)c \
                $::qspy::QS_RX(PEEK) 0x20000123 16]
@endcode


<div class="separate"></div>
@subsection udp_POKE  Poke Target Memory (POKE)
This packet has Record-ID==POKE and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Poke-addr  | Target-dependent@n Typically i | Address of the data in the Target
Poke-length| c             | Number of bytes to poke (<= 8)
Poke-data  | user-defined  | Binary data to poke to the Target (8 bytes maximum)

@note
The Poke-data part of the Data Payload must be formatted with the particular endianness of the Target and with any padding required for proper alignment of objects in the Target memory.

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format c$::qspy::theFmt(objPtr)cccs \
        $::qspy::QS_RX(POKE) 0x20000123 0x11 0x22 0x1122]
@endcode


<div class="separate"></div>
@subsection udp_GLB_FILTER  Set Global Filters in the Target (GLB_FILTER)
This packet has Record-ID==GLB_FILTER and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Data Len   | c             | Number of bytes sent (currently 16)
Filters    | b128          | 128 bits, each bit corresponding to Global Filter

<strong>Code Example:</strong>
@code
::qspy::sendPkt \
    [binary format ccb128 $::qspy::QS_RX(GLB_FILTER) 16 $theGlbFilter]
@endcode


<div class="separate"></div>
@subsection udp_LOC_FILTER  Set Local Filters in the Target (LOC_FILTER)
This packet has Record-ID==LOC_FILTER and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
Local filter #| c          | The Number of the Local Filter
Object-addr   | Target-dependent@n Typically i | Address of the object in the Target

The Local filters are numbered as follows:

0. State Machine Local Filter (SM)
1. Active Object Local Filter (AO)
2. Memory Pool Local Filter (MP)
3. Event Queue Local Filter (EQ)
4. Time Event Local Filter (TE)
5. Application-Specific Local Filter (AP)

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format cc$::qspy::theFmt(objPtr) \
                $::qspy::QS_RX(LOC_FILTER) 0 $theLocFilter(SM)]
@endcode


<div class="separate"></div>
@subsection udp_AO_FILTER  Set Local AO Filter in the Target (AO_FILTER)
This packet provides a shortcut for setting the Active Object Local Filter by providing just the unique priority of the AO.
The packet has Record-ID==AO_FILTER and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
AO prio    | c             | Priority of the AO to filter (0 to disable the AO filter)

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format cc $::qspy::QS_RX(AO_FILTER) 5]
@endcode


<div class="separate"></div>
@subsection udp_EVENT  Inject an Event to the Target (EVENT)
This packet has Record-ID==EVENT and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
AO prio    | c             | Priority of the recipient AO (0 to publish the event)
signal     | Target-dependent@n Typically s  | signal of the event
parameters | user-defined  | Binary data corresponding to all event parameters

The Event signal and parameters must be formatted with the particular endianness of the Target and with any padding required for proper alignment of objects in the Target memory.

The event signal `sig` must be formatted according to the Target configuration (see <a href="https://www.state-machine.com/qpc/qep_8h.html#afdaa94c40e947b0340b4259eddce3561" target="_blank" class="extern">Q_SIGNAL_SIZE</a>)

The parameters need to match exactly the event memory layout in your Target, including the endianness and any padding that the Target compiler might be using. (To test the right binary format and padding, you can use the @ref qspyview_events "Generate Event..." command).

For example, let's assume that the parameters of your event are: a byte, followed by a 2-byte integer, followed by a 4-byte integer. Also, let's assume that your Target is little endian. From the @ref qspyview_events "Generate Event..." command you discover that to format this event correctly you need to use the following event parameters:

Par # | format | data (example)
------|--------|-------------
par1: | c      | 0x11
par2: | c      | 0x00
par3: | s      | 0x1122
par4: | i      | 0x11223344

As you can see, you need to use "padding" (par2) after the first byte. You also use little endian encoding (`s`, `i`, format specification as opposed to `S`, `I`).

With this information, you can generate the packet programmatically.

<strong>Code Example:</strong>
@code
::qspy::sendEvent 7 5 [binary format ccsi 0x11 0x00 0x1122 0x11223344]
@endcode

@note
The qspy.tcl module provides specialized procedure `::qspy::sendEvent prio sig par` for injecting events to the Target.


------------------------------------------------------------------------------
@section udp_QSPY Packets to the QSPY Back-End


<div class="separate"></div>
@subsection udp_ATTACH  Attach to the QSPY Back-End (ATTACH)
This packet has Record-ID==ATTACH and Data Payload of the form:

Data item  | binary format | description
-----------|---------------|-------------
channels   | c             | Binary bitmask of @ref udp_channel "QSPY channels" to attach to

<strong>Code Example:</strong>
@code
::qspy::sendPkt [binary format cc $QSPY(ATTACH) $channels]
@endcode


<div class="separate"></div>
@subsection udp_DETACH Detach from the QSPY Back-End (DETACH)
This packet has Record-ID==DETACH and has no Data Payload.


<div class="separate"></div>
@subsection udp_SAVE_DIC  Save Dictionaries to a File in QSPY (SAVE_DIC)
This packet has Record-ID==SAVE_DIC and has no Data Payload.


<div class="separate"></div>
@subsection udp_SCREEN_OUT Toggle Screen Output to a File in QSPY (SCREEN_OUT)
This packet has Record-ID==SCREEN_OUT and has no Data Payload.


<div class="separate"></div>
@subsection udp_BIN_OUT Toggle Binary Output to a File in QSPY (BIN_OUT)
This packet has Record-ID==BIN_OUT and has no Data Payload.


<div class="separate"></div>
@subsection udp_MATLAB_OUT Toggle MATLAB Output to a File in QSPY (MATLAB_OUT)
This packet has Record-ID==MATLAB_OUT and has no Data Payload.


<div class="separate"></div>
@subsection udp_MSCGEN_OUT Toggle MscGen Output to a File in QSPY (MSCGEN_OUT)
This packet has Record-ID==MSCGEN_OUT and has no Data Payload.



------------------------------------------------------------------------------
@section udp_from Packets from the QSPY Back-End

<div class="separate"></div>
@subsection udp_from_ATTACH  Attach Response from the QSPY Back-End (ATTACH)
This packet has Record-ID==ATTACH and has no Data Payload.

@note
This packet is handled internally by the <span class="img file_tcl">qspy.tcl</span> script (see the ::qspy::pkt128 procedure)

<div class="separate"></div>
@subsection udp_from_DETACH  Detach Request from the QSPY Back-End (DETACH)
This packet has Record-ID==DETACH and has no Data Payload.

@note
This packet is handled internally by the <span class="img file_tcl">qspy.tcl</span> script (see the ::qspy::pkt129 procedure)

@next{qspy_matlab}
*/
/*###########################################################################*/
/**
@page qspy_matlab QSPY MATLAB Support

@tableofcontents

<p>The QSPY host application can also export trace data to <a href="http://www.mathworks.com/products/matlab/" target="_blank" class="extern">MATLAB</a>&reg;, which is a popular numerical computing environment and a high-level technical programming language. Created by The MathWorks, Inc., MATLAB allows easy manipulation and plotting of data represented as matrices.
</p>

@note
The QSPY MATLAB interface is also compatible with the <a href="http://www.gnu.org/software/octave/" target="_blank" class="extern">GNU Octave</a> environment, which is an open source alternative to MATLAB and is compatible with the QSPY MATLAB interface described below.

The following sections provide a reference manual for all 11 the MATLAB matrices generated by the @c qspy.m script. By MATLAB convention, the different variables are put into columns, allowing observations to vary down
through the rows. Therefore, a data set consisting of twenty four time samples of six variables is stored in a matrix of size 24-by-6. The pound sign '#' in a given cell of the matrix represents data available from the target. Other values, represent data added by the @c qspy.m script to allow unambiguous identification of the trace records.

- @ref MATLAB_Q_STATE
- @ref MATLAB_Q_ACTIVE
- @ref MATLAB_Q_EQUEUE
- @ref MATLAB_Q_MPOOL
- @ref MATLAB_Q_NEW
- @ref MATLAB_Q_PUB
- @ref MATLAB_Q_TIME
- @ref MATLAB_Q_INT
- @ref MATLAB_Q_ISR
- @ref MATLAB_Q_MUTEX
- @ref MATLAB_Q_SCHED


-------------------------------------------------------------------------------
@section MATLAB_Q_STATE Q_STATE Matrix
<p>The N-by-6 @c Q_STATE matrix stores all QS records generated by the QEP hierarchical event processor and pertaining to all the state machines in the system. The following table summarizes how the QS records are stored in the matrix:
</p>
<TABLE SUMMARY="Q_STATE Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
    <TD><B>6</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Signal</B></TD>
    <TD><B>State@n Machine@n Object</B></TD>
    <TD><B>Source@n State</B></TD>
    <TD><B>New@n State</B></TD> <TD><B>Event@n Hanlder</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QEP_STATE_ENTRY</TD>
    <TD>NaN</TD>
    <TD>1</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QEP_STATE_EXIT</TD>
    <TD>NaN</TD>
    <TD>2</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QEP_STATE_INIT</TD>
    <TD>NaN</TD>
    <TD>3</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QEP_INIT_TRAN</TD>
    <TD>#</TD>
    <TD>3</TD>
    <TD>#(2)</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QEP_INTERN_TRAN</TD>
    <TD>#</TD>
    <TD>#(1)</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QEP_TRAN</TD>
    <TD>#</TD>
    <TD>#(1)</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QEP_IGNORED</TD>
    <TD>#</TD>
    <TD>#(1)</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QEP_DISPATCH</TD>
    <TD>#</TD>
    <TD>#(1)</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QEP_UNHANDLED</TD>
    <TD>NaN</TD>
    <TD>#(1)</TD>
    <TD>#(2)</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>
</TABLE>
(1) The valid USER signal is &gt; 3

(2) Per inheritance, an active object is a state machine object as well


The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_STATE matrix:

<TABLE SUMMARY="Q_STATE records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QEP_STATE_ENTRY</TD>
    <TD><TT>Q_STATE(:,2) == 1</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QEP_STATE_EXIT</TD>
    <TD><TT>Q_STATE(:,2) == 2</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QEP_STATE_INIT</TD>
    <TD><TT>Q_STATE(:,2) == 3</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QEP_INIT_TRAN</TD>
    <TD><TT>isnan(Q_STATE(:,4))</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QEP_INTERN_TRAN</TD>
    <TD><TT>Q_STATE(:,2) &gt; 3 & isnan(Q_STATE(:,5))</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QEP_TRAN</TD>
    <TD><TT>Q_STATE(:,2) > &gt; & ~isnan(Q_STATE(:,5))</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QEP_IGNORED</TD>
    <TD><TT>~Q_STATE(:,6)</TT></TD>
  </TR>

</TABLE>

For example, the following MATLAB plot shows the timing diagrams for all Philo state machines in the DPP example application made by the `philo_timing.m` script located in the directory `qtools/qspy/matlab` (see Section @ref qspy_files). The vertical axis represents states "thinking" (lowest), "hungry" (middle) and "eating" (top) states.

@image html FigQSPY.01.jpg "Timing diagrams for all Philo state machines."


-------------------------------------------------------------------------------
@section MATLAB_Q_ACTIVE Q_ACTIVE Matrix
<p>The N-by-5 @c Q_ACTIVE matrix stores QS records pertaining to adding/removing active objects and subscribing/unsubscribing to events from active objects. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_ACTIVE Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Signal</B></TD>
    <TD><B>Active@n Object</B></TD>
    <TD><B>QF@n Priority</B></TD>
    <TD><B>Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_ADD</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_REMOVE</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_SUBSCRIBE</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_UNSUBSCRIBE</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>-1</TD>
  </TR>
</TABLE>

The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_ACTIVE matrix:

<TABLE SUMMARY="Q_ACTIVE records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_ACTIVE_ADD</TD>
    <TD><TT>isnan(Q_ACTIVE(:,2)) & Q_ACTIVE(:,5) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_ACTIVE_REMOVE</TD>
    <TD><TT>isnan(Q_ACTIVE(:,2)) & Q_ACTIVE(:,5) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_ACTIVE_SUBSCRIBE</TD>
    <TD><TT>isnan(Q_ACTIVE(:,4)) & Q_ACTIVE(:,5) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_ACTIVE_UNSUBSCRIBE</TD>
    <TD><TT>isnan(Q_ACTIVE(:,4)) & Q_ACTIVE(:,5) &lt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_EQUEUE Q_EQUEUE Matrix
<p>The N-by-10 @c Q_EQUEUE matrix stores QS records pertaining to queuing events in the QF. Both the active object event queues and the "raw" thread-safe queues are included. The 'nUsed' field denotes the current number of used entries in the queue. The 'Maximum nUsed' filed denotes the maximum number of used entries since initialization (high watermark). Both fields contain the number of used entries in the queues ring-buffer plus one, to account for the extra location at the front of the queue. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_EQUEUE Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
    <TD><B>6</B></TD>
    <TD><B>7</B></TD>
    <TD><B>8</B></TD>
    <TD><B>9</B></TD>
    <TD><B>10</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Sender</B></TD>
    <TD><B>Event@n Queue (1)</B></TD>
    <TD><B>nFree</B></TD>
    <TD><B>Minimum@n Used</B></TD>
    <TD><B>Signal</B></TD>
    <TD><B>Pool ID</B></TD>
    <TD><B>Ref.@n Count</B></TD>
    <TD><B>LIFO</B></TD>
    <TD><B>Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_EQUEUE_INIT</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>0</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>0</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_POST_FIFO</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>0</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_POST_LIFO</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>1</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_GET</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>0</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_ACTIVE_GET_LAST</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>0</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_EQUEUE_POST_FIFO</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>1</TD>
    <TD>#</TD>
    <TD>0</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_EQUEUE_POST_LIFO</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>1</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_EQUEUE_GET</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>0</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_EQUEUE_GET_LAST</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>0</TD>
    <TD>-1</TD>
  </TR>
</TABLE>
(1) This field (index 3) is actually the pointer to the ring buffer of the queue.

The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_EQUEUE matrix:

<TABLE SUMMARY="Q_EQUEUE records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_EQUEUE_INIT</TD>
    <TD><TT>Q_EQUEUE(:,10) == 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_ACTIVE_POST_FIFO</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;active obj&gt; & ~Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_ACTIVE_POST_LIFO</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;active obj&gt; & Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_ACTIVE_GET</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;active obj&gt; & ~isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_ACTIVE_GET_LAST</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;active obj&gt; & isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_EQUEUE_POST_FIFO</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;raw queue&gt; & ~Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_EQUEUE_POST_LIFO</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;raw queue&gt; & Q_EQUEUE(:,9) & Q_EQUEUE(:,10) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_EQUEUE_GET</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;raw queue&gt; & ~isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_EQUEUE_GET_LAST</TD>
    <TD><TT>Q_EQUEUE(:,3) == &lt;raw queue&gt; & isnan(Q_EQUEUE(:,4) & Q_EQUEUE(:,10) &lt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_MPOOL Q_MPOOL Matrix
<p>The N-by-5 @c Q_MPOOL matrix stores QS records pertaining to memory pools in the QF. The 'nFree' field denotes the current number of free blocks in the event pool. The 'Minimum nFree' filed denotes the minimal number of free blocks since initialization (low watermark). The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_MPOOL Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Pool@n Object</B></TD>
    <TD><B>nFree</B></TD>
    <TD><B>Minimal@n nFree</B></TD>
    <TD><B>Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_MPOOL_INIT</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_MPOOL_GET</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_MPOOL_PUT</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>+1</TD>
  </TR>
</TABLE>

The cumulative sum over the 'Delta' column should not have any long-time trends, because this would indicate a leak from the pool. The following picture shows the plot for the test data.

@image html FigQSPY.02.jpg "Plot stairs(Q_MPOOL(:,1), cumsum(Q_MPOOL(:,5)))"

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_MPOOL matrix:

<TABLE SUMMARY="Q_MPOOL records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_MPOOL_INIT</TD>
    <TD><TT>Q_MPOOL(:,5) == 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_MPOOL_GET</TD>
    <TD><TT>Q_MPOOL(:,5) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_MPOOL_PUT</TD>
    <TD><TT>Q_MPOOL(:,5) &gt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_NEW Q_NEW Matrix
<p>The N-by-6 @c Q_NEW matrix stores QS records pertaining to dynamic event allocation and automatic event recycling (garbage collection) in the QF. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_NEW Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
    <TD><B>6</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Signal</B></TD>
    <TD><B>PoolID</B></TD>
    <TD><B>Ref.@n Count</B></TD>
    <TD><B>Event@n Size</B></TD>
    <TD><B>Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_NEW</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_GC_ATTEMPT</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_GC</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>-1</TD>
  </TR>
</TABLE>

The cumulative sum over the 'Delta' column should not have any long-time trends, because this would indicate event leak. The following picture shows the plot for the test data.

@image html FigQSPY.03.jpg "Plot stairs(Q_NEW(:,1), cumsum(Q_NEW(:,6)))"

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_NEW matrix:

<TABLE SUMMARY="Q_NEW records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_NEW</TD>
    <TD><TT>%Q_NEW(:,6) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_GC_ATTEMPT</TD>
    <TD><TT>%Q_NEW(:,6) == 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_GC</TD>
    <TD><TT>%Q_NEW(:,6) &lt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_PUB Q_PUB Matrix
<p>The N-by-7 @c Q_PUB matrix stores QS records pertaining to publishing events in QF. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_PUB Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
    <TD><B>6</B></TD>
    <TD><B>7</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Sender</B></TD>
    <TD><B>Signal</B></TD>
    <TD><B>PoolID</B></TD>
    <TD><B>Ref.@n Count</B></TD>
    <TD><B># Events@n Multicast</B></TD>
    <TD><B>Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_PUBLISH</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
  </TR>
</TABLE>

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_PUB matrix:

<TABLE SUMMARY="Q_PUB records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_PUBLISH</TD>
    <TD><TT>Q_PUB(:,7) &gt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_TIME Q_TIME Matrix
<p>The N-by-7 @c Q_TIME matrix stores QS records pertaining to time events in QF. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_TIME Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
    <TD><B>5</B></TD>
    <TD><B>6</B></TD>
    <TD><B>7</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>QTimeEvt@n Object</B></TD>
    <TD><B>Signal</B></TD>
    <TD><B>QActive@n Object</B></TD>
    <TD><B>QTimeEvt@n Counter</B></TD>
    <TD><B>QTimeEvt@n Interval</B></TD>
    <TD><B>QTimeEvt@n Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_TICK</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>#(1)</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_TIMEEVT_ARM</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_TIMEEVT_DISARM</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_TIMEEVT_AUTO_DISARM</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>-1</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_TIMEEVT_DISARM_ATTEMPT</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_TIMEEVT_REARM</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#(2)</TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_TIMEEVT_POST</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>NaN</TD>
    <TD>NaN</TD>
    <TD>0</TD>
  </TR>
</TABLE>
(1) For #QS_QF_TICK record this matrix element contains the Tick Counter.

(2) For #QS_QF_TIMEEVT_REARM event this matrix element is 0 if the time event was disarmed and rearmed again, and 1 if the time event was only armed.

The cumulative sum over the 'Delta' column indicates the total number of armed time events at any given time. The following picture shows the plot for the test data:

@image html FigQSPY.04.jpg "Plot stairs(Q_TIME(:,1), cumsum(Q_TIME(:,7)))"

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_TIME matrix:

<TABLE SUMMARY="Q_TIME records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_TICK</TD>
    <TD><TT>isnan(Q_TIME(:,2))</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_TIMEEVT_ARM</TD>
    <TD><TT>Q_TIME(:,7) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_TIMEEVT_DISARM</TD>
    <TD><TT>~isnan(Q_TIME(:,1)) & Q_TIME(:,7) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_TIMEEVT_AUTO_DISARM</TD>
    <TD><TT>isnan(Q_TIME(:,1)) & Q_TIME(:,7) &lt; 0</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_TIMEEVT_DISARM_ATTEMPT</TD>
    <TD><TT>isnan(Q_TIME(:,3)) & isnan(Q_TIME(:,5)) & Q_TIME(:,7) == 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_TIMEEVT_REARM</TD>
    <TD><TT>isnan(Q_TIME(:,3)) & ~isnan(Q_TIME(:,5))</TT></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_TIMEEVT_POST</TD>
    <TD><TT>~isnan(Q_TIME(:,3)) & ~isnan(Q_TIME(:,4))</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_INT Q_INT Matrix
<p>The N-by-3 @c Q_INT matrix stores QS records pertaining to interrupt disabling and enabling. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_INT Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Interrupt@n Nesting</B></TD>
    <TD><B>Nesting@n Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_INT_DISABLE</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_INT_ENABLE</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>-1</TD>
  </TR>
</TABLE>

The cumulative sum over the 'Delta' column indicates interrupt lock nesting
and should closely follow column 2.

The following criteria (index matrices in MATLAB) unambiguously select the QS
records from the @c Q_INT matrix:

<TABLE SUMMARY="Q_INT records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_INT_DISABLE</TD>
    <TD><TT>Q_INT(:,3) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_INT_ENABLE</TD>
    <TD><TT>Q_INT(:,3) &lt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_ISR Q_ISR Matrix
<p>The N-by-4 @c Q_ISR matrix stores QS records pertaining to interrupt entry and exit. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_ISR Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Interrupt@n Nesting</B></TD>
    <TD><B>ISR@n Priority</B></TD>
    <TD><B>Nesting@n Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QF_ISR_ENTRY</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QF_ISR_EXIT</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>-1</TD>
  </TR>
</TABLE>

The cumulative sum over the 'Delta' column indicates interrupt nesting level and should closely follow column 2.

The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_ISR matrix:

<TABLE SUMMARY="Q_ISR records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QF_ISR_ENTRY</TD>
    <TD><TT>Q_ISR(:,4) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QF_ISR_EXIT</TD>
    <TD><TT>Q_ISR(:,4) &lt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_MUTEX Q_MUTEX Matrix
<p>The N-by-4 @c Q_MUTEX matrix stores QS records pertaining to the priority-ceiling mutex activity in QK. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_MUTEX Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
    <TD><B>4</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Original@n Priority</B></TD>
    <TD><B>Priority@n Ceiling</B></TD>
    <TD><B>Nesting@n Delta</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QK_MUTEX_LOCK</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>+1</TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD>@c #QS_QK_MUTEX_UNLOCK</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>-1</TD>
  </TR>
</TABLE>


The cumulative sum over the 'Delta' column indicates QK scheduler lock nesting level.

@image html FigQSPY.05.jpg "Plot stairs(Q_MUTEX(:,1), cumsum(Q_MUTEX(:,4)), 'r') (red)"


The following criteria (index matrices in MATLAB) unambiguously select the QS records from the @c Q_ISR matrix:

<TABLE SUMMARY="Q_ISR records" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>QS Record</B></TD>
    <TD><B>MATLAB Index Matrix</B></TD>
  </TR>

  <TR bgColor="#f0f0f0">
    <TD>@c #QS_QK_MUTEX_LOCK</TD>
    <TD><TT>Q_MUTEX(:,4) &gt; 0</TT></TD>
  </TR>

  <TR bgColor="#c0c0c0">
    <TD>@c #QS_QK_MUTEX_UNLOCK</TD>
    <TD><TT>Q_MUTEX(:,4) &lt; 0</TT></TD>
  </TR>
</TABLE>


-------------------------------------------------------------------------------
@section MATLAB_Q_SCHED Q_SCHED Matrix
<p>The N-by-3 @c Q_SCHED matrix stores QS records pertaining to scheduling next task in QK. The following table summarizes how the QS records are stored in the matrix:
</p>

<TABLE SUMMARY="Q_MUTEX Matrix" cellSpacing=4 cellPadding=1 border=0
ALIGN="center">
  <TR bgColor="#c8cedc" ALIGN="center">
    <TD><B>&nbsp;MATLAB index --&gt;</B></TD>
    <TD><B>1</B></TD>
    <TD><B>2</B></TD>
    <TD><B>3</B></TD>
  </TR>

  <TR bgColor="#f0f0f0" ALIGN="center">
    <TD><B>QS Record@n |@n V</B></TD>
    <TD><B>Time@n Stamp</B></TD>
    <TD><B>Preempted@n Priority</B></TD>
    <TD><B>New@n Priority</B></TD>
  </TR>

  <TR bgColor="#c0c0c0" ALIGN="center">
    <TD>@c #QS_QK_SCHEDULE</TD>
    <TD>#</TD>
    <TD>#</TD>
    <TD>#</TD>
  </TR>
</TABLE>


@next{qspy_mscgen}
*/
/*###########################################################################*/
/**
@page qspy_mscgen QSPY MscGen Support

The QSPY host application can also save the tracing data in the format suitable for the <a href="http://www.mcternan.me.uk/mscgen/" target="_blank" class="extern">MscGen utility</a> to generate <strong>sequence diagrams</strong>.

@note The MscGen utility is also available in the <b>Qtools</b> collection (the same that contains QSPY itself, see @ref install "Installing").

To generate an MscGen file, you need to invoke QSPY with  the `-g` @ref qspy_command "command-line option", or to hit the `g` @ref qspy_keyboard "key-stroke" while QSPY is running.


@note
The generation of sequence diagrams relies on the following QS trace records being enabled: #QS_QF_ACTIVE_POST_FIFO, #QS_QF_ACTIVE_POST_LIFO. Additional annotations of the sequence diagrams are also available if the following QS trace records are enabled: #QS_QF_PUBLISH, #QS_QF_TICK, and #QS_QEP_TRAN.

Subsequently, you need to invoke the MscGen utility to convert the generated file to graphical format, such as .PNG, .EPS, .SVG, or .ISMAP. For example, the following command generates a sequence diagram in .SVG from the dpp.msc file.

@verbatim
mscgen -Tsvg -idpp.msc
@endverbatim

The following screen shot shows a sequence diagram generated from the Dining Philosophers Problem (DPP) application. The .MSC file has been converted to .SVG and viewed in a web browser (Google Chrome in this case).

@image html mscgen_dpp.gif

@note
The numbers proceeding the signal names in the diagram are the Target time-stamps.

@next{qutest}
*/
