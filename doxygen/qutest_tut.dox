/*! @page qutest_tut QUTest&trade; Tutorial

<p>This Tutorial describes how to use the QUTest&trade; unit test harness in a series of progressively advancing examples. The first couple of examples pertain to generic C code completely unrelated to the QP frameworks. These examples are adaptations of tests shipping with the <a href="http://www.throwtheswitch.org/unity" target="_blank" class="extern"><b>Unity test framework</b></a>. Later examples in this Tutorial show how to test <a href="https://www.state-machine.com/doc/concepts#HSM" target="_blank" class="extern"><b>hierarchical state machines</b></a> and <a href="https://www.state-machine.com/doc/concepts#Active" target="_blank" class="extern"><b>active objects</b></a>. It is highly recommended to study the simpler examples before the more advanced ones, as the basic information won't be repeated in the later tests.
</p>

As mentioned in the Section \"@ref qutest_how "How it works?"\", testing with QUTest&trade; always involves two components: (1) a @ref qutest_fixture "test fixture" code written in <b>C</b> (or <b>C++</b>) that runs on the target and (2) one or more @ref qutest_script "test scipts" that are written in <b>Python</b> and run on the host. This Tutorial starts each example with the description of how to run the tests and then explains the *test fixture* and the *test scripts* comprising the test.

@note
This Tutorial should run on any host computer (Windows, Linux, or MacOS), where both QTools&trade; and [<b>QP/C framework</b>](/qpc) have been installed and also that the **QTOOLS** environment variable has been defined. Please refer to the @ref install "QTools Installation" section for more information about downloading and installing QTools&trade;.


This Tutorial consists of the following lessons:

- @subpage qutest_unity
- @subpage qutest_mock
- @subpage qutest_qhsm
- @subpage qutest_blinky
- @subpage qutest_dpp

@next{qutest_unity}
*/

/*###########################################################################*/
/*! @page qutest_unity Basic Unity Example

@tableofcontents

<p>This example is based on the simple `example_1` that ships with the <a href="http://www.throwtheswitch.org/unity" target="_blank" class="extern"><b>Unity unit testing framework</b></a>. This simplest example of Unity has nothing to do with the QP frameworks. The purpose is to illustrate that QUTest&trade; can be used with generic C code and to compare QUTest&trade; with Unity.
</p>

@remark
This simple example runs QUTest tests on the host (Windows, Linux, or MacOS) for both Unity and QUTest. The QUTest version also runs on embedded boards (TivaC LaunchPad from Texas Instruments and EFM32 Pearl-Gecko board from Silicon Labs). The instructions for building and running the code on the embedded boards are located at the end of this lesson.
@n
![](platforms.png)


------------------------------------------------------------------------------
@section qutest_unity-cut Code Under Test (CUT)

@note
Because it uses pure C code, the Basic Unity example is only available in the [<b>QP/C framework</b>](https://www.state-machine.com/qpc) (and is **not** available in the [QP/C++ framework](https://www.state-machine.com/qpcpp)).


The CUT in this example is the file <span class="img file_c">`ProductionCode.c`</span> located in the directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_basic\src`</span>. The CUT contains just two functions with some fairly obvious errors. The purpose of the example is to find these errors by unit-testing this "production code":

@anchor qutest_tut_basic-cut
@includelineno ProductionCode.c


------------------------------------------------------------------------------
@section qutest_unity-run0 Running the Test with Unity
The complete code for the basic Unity example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_basic\test_unity`</span>. To run the basic Unity test (on Windows), open a command-prompt and type:
@verbatim
cd C:\qp\qpc\examples\qutest\unity_basic\test_unity
make
@endverbatim

@note
The provided `Makefile` will also work on Linux and MacOS. The only difference from Winows is that you open a terminal window and change directory to <span class="img folder">`~/qp/qpc/examples/qutest/unity_basic/test_unity`</span>.


This will build the @ref qutest_unity-fixture "test fixture" as a host executable and then it will run it. The screen shot below shows the output produced from the make command.

![Unity example_1 test build and run with Unity](unity_basic_unity.png)


@remark
As you can see, two out of five Unity tests **fail**. This is intentional, because the CUT is faulty.


------------------------------------------------------------------------------
@section qutest_unity-run Running the Test with QUTest
The complete code for the basic Unity example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_basic\test`</span>. To run the basic test (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY host utility" with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open a **second** command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\unity_basic\test
make
@endverbatim

@note
The provided `Makefile` will also work on Linux and MacOS. The only difference from Windows is that you open a terminal window and change directory to <span class="img folder">`~/qp/qpc/examples/qutest/unity_basic/test`</span>.


This will build the @ref qutest_unity-fixture "test fixture" as a host executable and then it will run the @ref qutest_unity-script "test script" (in Python). The screen shot below shows the output produced in these two command-prompt windows.

![Unity example_1 test build and run with QUTest (left) and QSPY output (right).](unity_basic_qutest.png)

@remark
As you can see, two out of five QUTest tests **fail**. These are the same tests (adapted for QUTest) that failed during testing with Unity above.


------------------------------------------------------------------------------
@section qutest_unity-fixture Test Fixture
The job of a @ref qutest_fixture "test fixture" is to exercise the <a href="https://www.state-machine.com/glossary#CUT" class="extern"><b>CUT</b></a> (<span class="img file_c">`ProductionCode.c`</span> in this case) and report the results back to the @ref qspy "QSPY host application". Note that a *test fixture* in QUTest&trade; is **not** supposed to perform any checks whether the CUT operates "correctly". Instead, your *test fixture* should only provide facilities to thoroughly exercise the **CUT** remotely from the  @ref qutest_unity-script "test script"(s). A properly written test fixture can be typically used for many tests (implemented in multiple test scripts).

@remark
Coming up with a "good" *test fixture* requires some practice, but when you study the examples in this Tutorial, you will see some instances of flexible *test fixtures* that allow you to to run a wide variety of tests on them.


The following listing shows the complete QUTest *test fixture* for the basic tests (file <span class="img file_c">`test_ProductionCode.c`</span> in the directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_basic\test`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code
 [1] #include "qpc.h"  /* QUTest interface */
 [2] #include "ProductionCode.h" /* CUT interface */

 [3] Q_DEFINE_THIS_FILE

     /*--------------------------------------------------------------------------*/
     // sometimes you may want to get at local data in a module.
     // for example: If you plan to pass by reference, this could be useful
     // however, it should often be avoided
 [4] extern int Counter;

     /*--------------------------------------------------------------------------*/
 [5] int main(int argc, char *argv[]) {

 [6]     QF_init();  /* initialize the framework */

         /* initialize the QS software tracing */
 [7]     Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

         /* dictionaries... */
 [8]     QS_FUN_DICTIONARY(&FindFunction_WhichIsBroken);
 [9]     QS_FUN_DICTIONARY(&FunctionWhichReturnsLocalVariable);
[10]     QS_OBJ_DICTIONARY(&Counter);

         /* filter setup... */
[11]     QS_FILTER_ON(QS_ALL_RECORDS);

[12]     return QF_run(); /* run the tests */
     }

     /*--------------------------------------------------------------------------*/
[13] void QS_onTestSetup(void) {
     }
     /*..........................................................................*/
[14] void QS_onTestTeardown(void) {
     }

     /*..........................................................................*/
[15] void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         switch (cmdId) {
             case 0: { /* call the CUT: FindFunction_WhichIsBroken */
[16]             int ret = FindFunction_WhichIsBroken((int)param1);
[17]             QS_BEGIN(QS_USER + cmdId, (void *)0) /* user-specific record */
[18]                 QS_FUN(&FindFunction_WhichIsBroken); /* function called */
[19]                 QS_I32(0, (int32_t)ret); /* returned value */
[20]                 QS_I16(0, (int16_t)param1); /* parameter */
[21]             QS_END()
                 break;
             }
             case 1: { /* call the CUT: FunctionWhichReturnsLocalVariable */
[22]             int ret = FunctionWhichReturnsLocalVariable();
[23]             QS_BEGIN(QS_USER + cmdId, (void *)0) /* user-specific record */
[24]                 QS_FUN(&FunctionWhichReturnsLocalVariable); /* function called */
[25]                 QS_U32_HEX(0, (uint32_t)ret); /* returned value */
[26]             QS_END()
                 break;
             }
             default:
                 break;
         }

         /* unused parametrers... */
         //(void)param1;
         (void)param2;
         (void)param3;
     }
     /*..........................................................................*/
     /* host callback function to "massage" the event, if necessary */
[27] void QS_onTestEvt(QEvt *e) {
         (void)e;
     #ifdef Q_HOST  /* is this test compiled for a desktop Host computer? */
     #else /* this test is compiled for an embedded Target system */
     #endif
     }
     /*..........................................................................*/
     /*! callback function to output the posted QP events (not used here) */
[28] void QS_onTestPost(void const *sender, QActive *recipient,
                        QEvt const *e, bool status)
     {
         (void)sender;
         (void)recipient;
         (void)e;
         (void)status;
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file contains the [QP/C framework](https://www.state-machine.com/qpc/) API, which includes the QUTest interface. Typically, you need to include this header file in QUTest test doubles.
> **NOTE:** for test fixtures based on the [QP/C++ framework](https://www.state-machine.com/qpcpp/), you need to include the `"qpcpp.h"` header file.
  </dd>
  <dt>[2]</dt><dd> You also need to include the interface to the CUT, which is `ProductionCode.h` in this case.
  </dd>
  <dt>[3]</dt><dd> The macro `Q_DEFINE_THIS_FILE` is needed for <a href="https://www.state-machine.com/glossary#assertion" class="extern"><b>DbC assertions</b></a> (they have nothing to do with <a href="https://www.state-machine.com/glossary#test_assertion" class="extern">test assertions</a>). Later in this file, a <a href="https://www.state-machine.com/glossary#assertion" class="extern">DbC assertion</a> is used to guard against failure in the initialization of the @ref qs "QS" target-resident component (see step [7]).
  </dd>
  <dt>[4]</dt><dd> The variable `Counter` is used to control the return value from the CUT (see @ref qutest_tut_basic-cut "ProductionCode.c" line 4).
  > <b>NOTE:</b> this approach breaks encapsulation of the CUT, but it is copied here from the original Unity test.
  </dd>
  <dt>[5]</dt><dd> A QUTest *test fixture* code needs the `main()` function. This `main()` function can be in a separate file, but in this simple example it is placed in `test_ProductionCode.c`. Either way, the `main()` function has the usual structure of a QP/C application (and in fact in the more advanced tests it can be *the same* function as used by the actual QP/C application). But here, it contains the bare minimum function calls, as described below.
  </dd>
  <dt>[6]</dt><dd> The `main()` function must start with calling `QF_init()` to initialize the QP framework.
  </dd>
  <dt>[7]</dt><dd> Next, you need to initialize the @ref qs "QS" target-resident component (QS_INIT()). This macro is wrapped with the <a class="extern" href="https://www.state-machine.com/qpc/qassert_8h.html#aa0c75140aa3855c94e453b06567dcc28"><b>Q_ALLEGE()</b></a> assertion, which will fire if the QS initialization fails. (In which case continuationon of the test makes no sense).
  </dd>
  <dt>[8-10]</dt><dd> Next, you produce @ref qs_dict "QS dictionaries" for all functions you wish to test as well as objects you might need to inspect.
> <b>NOTE:</b> you need to do this, so that the test scripts can refer to the functions and objects by the same symbolic names as the CUT/test-fixture.
  </dd>
  <dt>[11]</dt><dd> The QS_FILTER_ON() macro sets the @ref qs_global "global filter" in the Target. Here all output is enabled (::QS_ALL_RECORDS).
  </dd>
  <dt>[12]</dt><dd> Finally, at the end of `main()` you need to call `QF_run()` to run the tests.
  </dd>
  <dt>[13]</dt><dd> The callback function `QS_onTestSetup()` allows you to include code that will be run at the beginning of each test. Here this simple CUT does not need any setup, but you still need to provide (an empty) implementation to satisfy the linker.
  </dd>
  <dt>[14]</dt><dd> The callback function `QS_onTestTeardown()` allows you to include code that will be run at the end of each test. Here this simple CUT does not need any teardown, but you still need to provide (an empty) implementation to satisfy the linker.
  </dd>
  <dt>[15]</dt><dd> The callback function `QS_onCommand()` allows you to remotely execute commands inside the Target. Here is where you execute the CUT and report results back to QSPY.
  </dd>
  <dt>[16]</dt><dd> The command with `cmdId==0` will be used to call the `FindFunction_WhichIsBroken()` CUT.
> <b>NOTE:</b> You can use other `cmdId`s to call other pieces of CUT or to provide different variants of calling the same CUT, as you see fit. Much of the art of writing *test fixtures* lies in constructing flexible remote commands that exercise your CUT.
  </dd>
  <dt>[17]</dt><dd> The `QS_BEGIN()` macro starts the @ref qs_app "application-specific" trace record that will report results of calling the `FindFunction_WhichIsBroken()` CUT to the test script.
  </dd>
  <dt>[18]</dt><dd> The `QS_FUN()` macro sends the address of the function to the test script. This address will be converted to the name of the function, because the dictionary for this function has been generated in setp 8.
  </dd>
  <dt>[19]</dt><dd> The `QS_I32()` macro sends a 32-bit signed integer (`int32_t`) to the test script. Here you output the return value from `FindFunction_WhichIsBroken()`.
  </dd>
  <dt>[20]</dt><dd> The `QS_I16()` macro sends a 16-bit signed integer (`int16_t`) to the test script. Here you output the argument passed to `FindFunction_WhichIsBroken()`.
  </dd>
  <dt>[21]</dt><dd> The `QS_END()` macro ends the @ref qs_app "application-specific" trace record.
  </dd>
@n
  <dt>[22]</dt><dd> The command with `cmdId==1` will be used to call the `FunctionWhichReturnsLocalVariable()` CUT.
  </dd>
  <dt>[23-26]</dt><dd> Again, the @ref qs_app "application-specific" trace record gets generated that reports the function address and the return value from this function call.
  </dd>
@n
  <dt>[27]</dt><dd> The `QS_onTestEvt()` callback function is not used in this test, but needs to be provided to satisfy the linker.
  </dd>
  <dt>[28]</dt><dd> The `QS_onTestPost()` callback function is not used in this test, but needs to be provided to satisfy the linker.
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_unity-script Test Script
A **test script** contains a group of related tests (a <em>"test group"</em>). The basic job of these tests is to send inputs to the *test fixture* running in the Target and to compare the produced @ref qspy_text "QSPY textual output" with the <b>expectations</b> of the test. The following listing shows the *test script* (Python) for the Unity basic tests (file <span class="img file_py">`test_ProductionCode.py`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@remark
Even though a *test script* uses <b>Python</b> under the hood, you don"t need to be a Python expert to write effective test scripts. The actual set of commands that you use and need to know about forms a small @ref qutest_script "Domain Specific Language (DSL) for unit testing", which just happens to be implemented with Python as a command interpreter.


@note
The following test script performs the same tests as the Unity test fixture <span class="img file_c">`TestProductionCode.c`</span> in the directory <span class="img folder">`qpc\examples\qutest\unity_basic\test_unity`</span>.


@code{py}
 [1] # QUTEST script corresponding to the test_ProductionCode.c test fixture.
     # This test fixture corresponds to ../test_unity/TestProductionCode.c fixture.
     # see https://www.state-machine.com/qtools/qutest.html

     # preamble...
 [2] def on_setup():
         # This is run before EACH TEST
 [3]     current_obj(OBJ_AP, "Counter")
 [4]     poke(0, 4, pack("<L", 0x5A5A))

     # tests...
 [5] test("FindFunction_WhichIsBroken() Should Return Zero If Item Is Not In List, Which Works Even In Our Broken Code")
     # All of these should pass
 [6] command(0, 78)
 [7] expect("0000000001 USER+000 FindFunction_WhichIsBroken 0 78")
 [8] expect("0000000002 Trg-Done QS_RX_COMMAND")
     command(0, 1)
     expect("0000000003 USER+000 FindFunction_WhichIsBroken 0 1")
     expect("0000000004 Trg-Done QS_RX_COMMAND")
     command(0, 33)
 [9] expect("@timestamp USER+000 FindFunction_WhichIsBroken 0 33")
     expect("@timestamp Trg-Done QS_RX_COMMAND")
     command(0, 999)
     expect("@timestamp USER+000 FindFunction_WhichIsBroken 0 999")
     expect("@timestamp Trg-Done QS_RX_COMMAND")
[10] command(0, (-1) & 0xFFFFFFFF)
     expect("@timestamp USER+000 FindFunction_WhichIsBroken 0 -1")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

[11] test("FindFunction_WhichIsBroken() Should Return The Index For Items In List, Which Will Fail Because Our Function Under Test Is Broken")
[12] command(0, 34)
[13] expect("@timestamp USER+000 FindFunction_WhichIsBroken 1 34")
     # Notice the rest of these didn"t get a chance to run because the line above failed.
     # Unit tests abort each test on the first sign of trouble.
     # Then NEXT test runs as normal.
     expect("@timestamp Trg-Done QS_RX_COMMAND")
     command(0, 8888)
     expect("@timestamp USER+000 FindFunction_WhichIsBroken 8 8888")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

[14] test("FunctionWhichReturnsLocalVariable() Should Return The Current Counter Value")
[15] command(1)
     expect("@timestamp USER+001 FunctionWhichReturnsLocalVariable 0x5A5A")
     expect("@timestamp Trg-Done QS_RX_COMMAND")
     # This should be true because we can still change our answer
[16] poke(0, 4, pack("<L", 0x1234))
     command(1)
     expect("@timestamp USER+001 FunctionWhichReturnsLocalVariable 0x1234")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

[17] test("FunctionWhichReturnsLocalVariable() Should Return The Current Counter Value Again", NORESET)
     # This should be true again because setup was rerun before this test (and after we changed it to 0x1234)
     command(1)
     expect("@timestamp USER+001 FunctionWhichReturnsLocalVariable 0x5A5A")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

     test("FunctionWhichReturnsLocalVariable() Should Return Current Counter, But Fails Because This Test Is Actually Flawed", NORESET)
     # Sometimes you get the test wrong.  When that happens, you get a failure too... and a quick look should tell
     # you what actually happened...which in this case was a failure to setup the initial condition.
     command(1)
     expect("@timestamp USER+001 FunctionWhichReturnsLocalVariable 0x1234")
     expect("@timestamp Trg-Done QS_RX_COMMAND")
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> Lines starting with a pound sign ('#') or empty lines are comments which are ignored by QUTest.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>"preamble"</strong> defines the startup code common to all tests in the group:
<dl class="tag">
  <dt>[2]</dt><dd> The function on_setup() is executed at the beginning of each test in the group (see test()), including both tests that reset and do not reset the Target.
  </dd>
  <dt>[3]</dt><dd> The current_obj() command sets the "current object" of the application-specific kind (`OBJ_AP`) in the Target. Subsequent commands (such as poke() in the next step) will act on this "current object".
  </dd>
  <dt>[4]</dt><dd> The poke() command pokes the specified "Application Current Object" starting with the specified offset from the beginning of the object in memory (here 0) with the data elements of size 4 (the second argument) with the data provided in the third argument @ref pack() "pack("<L", 0x5A5A)" into the previously established "Application Current Object".
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "FindFunction_WhichIsBroken() Should Return Zero..."</strong> checks that the CUT returns 0 when a given number is not found:
<dl class="tag">
  <dt>[5]</dt><dd> The test() command starts a test and gives it a name (in double quotes). The name of test will be displayed as the test is executed and should be a quick reminder about the objective of this test. This test command also @ref qutest_reset "resets the Target", which brings the Target into a well-defined initial state and produces the @ref qs_dict "QS dictionary records" (see @ref qutest_unity-fixture "test-fixture"[12])
> <b>NOTE:</b> The ability to perform the <b>full Target reset</b> is a unique feature of QUTest. Other unit testing frameworks, including Unity and CppUTest, don't reset the Target. They merely call the test `setup()/tearDown()` functions at the beginning and end of the test, respectively. QUTest also calls `onReset()/onSetup()/onTeardown()`, but obviously the full Target reset is a much better guarantee that the Target starts in exactly the same state.
  </dd>
  <dt>[6]</dt><dd> The command() command causes the invocation of the `QS_onCommand()` callback inside the Target. The argument 0 is the `cmdId` parameter (see @ref @ref qutest_unity-fixture "test-fixture"[16])
> **NOTE:** The first parameter of @ref command() "command" here is just a number (0), but it is also possible to use a **symbolic name** for the first parameter. This symbolic name will be looked up in the user dictionary (QS_USR_DICTIONARY())
  </dd>
  <dt>[7]</dt><dd> The expect() command represents an <b>expectation</b> of this test (a.k.a. <a href="https://www.state-machine.com/glossary#test_assertion">test assertion</a>). This is the expected output generated by the `command(0)` command from the previous step. You need to consult the test fixture to determine what you should expect in this case.
> <b>NOTE:</b> the expected string starts with a number `0000000001`, which is the @ref qs_tstamp "Target Time-Stamp". In QUTest, the @ref qutest_tstamp "timestamp" simply counts all the QS trace records produced, so that you know that no entries have been lost. In the later tests you will see how you can count the steps <b>automatically</b> with the `@timestamp` placeholder.
  </dd>
  <dt>[8]</dt><dd> The test finishes with the expectation for the `Trg-Done QS_RX_COMMAND` trace record, which means that all output generated by command() has been generated.
  </dd>
  <dt>[9]</dt><dd> This expect() command illustrate the use of the `@timestamp` placeholder to account for the test steps <b>automatically</b>.
  </dd>
  <dt>[10]</dt><dd> This command() illustrates how to pass **negative numbers** as arguments. As you can see, you need to binary-and the number with the all-bits-on bitmask `0xFFFFFFFF`.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "FindFunction_WhichIsBroken() Should Return The Index..."</strong> checks that the CUT fails to return the expected index, because of the internal bug:
<dl class="tag">
  <dt>[11]</dt><dd> The test() command starts a next test.
  </dd>
  <dt>[12]</dt><dd> This `command(0, 34)` should cause the function `FindFunction_WhichIsBroken()` to return index `1`, because the number `34` is actually in the list.
  </dd>
  <dt>[13]</dt><dd> This expect() command codifies the expected result of the function call.
  > <b>NOTE:</b> Due to the bug in the CUT, however, the expectation will fail, in which case the rest of the test is skipped until the **next** test() command.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "FunctionWhichReturnsLocalVariable() Should Return The Current Counter Value"</strong>:
<dl class="tag">
  <dt>[14]</dt><dd> The test() command starts a next test.
  </dd>
  <dt>[15]</dt><dd> This `command(1)` runs the second function `FunctionWhichReturnsLocalVariable()` in the CUT.
  </dd>
  <dt>[16]</dt><dd> This poke() command changes the value of the `Counter` variable, because this is the "current AP object" established in the on_setup() callback in step [3].
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Test: "FunctionWhichReturnsLocalVariable() Should Return The Current Counter..."</strong> checks whether `FunctionWhichReturnsLocalVariable()` CUT returns the value poked into the `Counter` variable:
<dl class="tag">
  <dt>[17]</dt><dd> The test() command starts a next test.
> <b>NOTE:</b> Unlike all previous tests so far, this test does **not** reset the Target (argument @ref qutest_reset "NORESET")
  </dd>
</dl>
<div style="clear:both;"></div>

@remark
As an exercise you should modify the file `ProductionCode.c` to fix the bug and make the tests pass.


------------------------------------------------------------------------------
@section qutest_unity-embed Running the Test on Embedded Targets
As mentioned at the initial description of this example, the directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_basic\test`</span> contains makefiles to build the code and run the tests on the embedded boards (TivaC LaunchPad from Texas Instruments and EFM32 Pearl-Gecko board from Silicon Labs). Both these boards open a virtual COM port on the machine they are attached to via the USB cable. This virtual COM port provides an ideal connection for the @ref qs "QS communication" with the @ref qspy "QSPY host utility".

![Targets for running QUTests. From the left: host computer, TivaC LaunchPad and EFM32 Pearl-Gecko](platforms.png)


For example, to test the EFM32 Pearl-Gecko board (ARM Cortex-M4), open a command prompt (on Windows) and type:

@verbatim
qspy -u -c COM6
@endverbatim


This will start the QSPY host utility with the UDP socket (-u option) and serial connection to the embedded board. Of course, you need to adjust the serial port number to the actual number of the virtual COM port on your machine.

Next, open a **second** command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\unity_basic\test
make -f make_efm32
@endverbatim

The rest of the test is then exactly the same as with the host executable described @ref qutest_unity-run "above", except that the @ref qutest_unity-fixture "test fixture" runs on the embedded board.

To run the tests on the TivaC LaunchPad (TM4C123 board), you use the `make_tm4c123` in the last step.


@next{qutest_mock}
*/

/*###########################################################################*/
/*! @page qutest_mock Unity Mock Example

@tableofcontents

<p>This example is loosely based on <a href="http://www.electronvector.com/about" target="_blank" class="extern"><b>Matt Chernosky's</b></a> video blog post <a href="http://www.electronvector.com/blog/test-driving-with-mocks-instead-of-hardware" target="_blank" class="extern"><b>"Test-driving with mocks instead of hardware"</b></a>. In this video blog, Matt presents a technique called the <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" class="extern"><b>mock object</b></a>, which in the traditional unit testing approach is needed to verify complex, multi-stage interactions between the CUT and the collaborator impersonated by the mock object.
</p>

@note
To better understand this QUTest example, it is highly recommended to watch the <a href="https://vimeo.com/256590562" target="_blank" class="extern"><b>Chernosky's video blog</b></a>.


The main purpose of this example is to show the traditional approach (with the mock object) and contrast it with the much simpler solution enabled by the QUTest approach.

@note
Because of the different design philosophy of QUTest, which is *not* based on xUnit, the classic "mock object" is actually not needed and can be replaced with a simpler "spy" <a href="https://en.wikipedia.org/wiki/Test_double" target="_blank" target="_blank" class="extern"><b>test double</b></a>. To dynamically alter the behavior of this "spy" test double, this example applies @ref qutest_fixture-probe "QUTest Test Probes". Test Probes can be changed interactively from the @ref qutest_mock-script "test script".


@remark
This example runs QUTest tests on the host (Windows, Linux, or MacOS) for both Unity and QUTest. The QUTest version also runs on embedded boards (TivaC LaunchPad from Texas Instruments and EFM32 Pearl-Gecko board from Silicon Labs). The instructions for building and running the code on the embedded boards are located at the end of this lesson.
@n
![](platforms.png)


------------------------------------------------------------------------------
@section qutest_mock-cut Code Under Test (CUT)

@note
Because it uses pure C code, the Basic Unity example is only available in the [<b>QP/C framework</b>](https://www.state-machine.com/qpc) (and is **not** available in the [QP/C++ framework](https://www.state-machine.com/qpcpp)).


This CUT in this example implements a simple bar of 5 LEDs that display percentage, as shown in the animation below. The "LedBar device" interacts with the discrete LEDs by turning them on and off, to achieve the desired effect. The main objective of this example is to demonstrate how to verify the **collaboration** with the discrete LEDs, even without the actual hardware.

![Bar of 5 LEDs displaying the percentage.](ledbar5.gif)

The LedBar CUT is located in the file <span class="img file_c">`LedBar.c`</span> in the directory <span class="img folder">`qpc\examples\qutest\unity_mock\src`</span>. The CUT consists of just one function `LedBar_setPercent()`, which turns the individual LEDs on and off such that they display the desired `percent` parameter. The function `LedBar_setPercent()` returns the total power consumption (in microwatts) of all LEDs that are turned on.

@anchor qutest_tut_mock-cut
@includelineno LedBar.c
<div class="caption" align="center">file LedBar.c</div>

The low-level interface to the LEDs is defined below (<span class="img file_h">`Led.h`</span>). The individual LEDs are selected by an `index` parameter. Each individual LED can be turned on by means of the `LED_on()` function. The `LED_on()` function returns a value, which corresponds to power consumption of this LED while on. The LED can be turned off by the `LED_off()` function, which returns `void`.

@anchor qutest_tut_mock-cut
@includelineno Led.h
<div class="caption" align="center">file Led.c</div>


The diagram below shows the relationships between the CUT and the test code: Unity case on the left and QUTest case on the right. In both cases, the `LedBar` CUT interacts with the hardware through the `Led.h` interface. The explanation section below the diagram clarifies the interesting elements of the diagram.

![Components of the Unity Mock test: Unity left and QUTest right](qutest_mock.gif)

<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Center: Code Under Test</strong>

<dl class="tag">
  <dt>[1]</dt><dd> The `LedBar.c` file contains the @ref qutest_mock-cut "Code Under Test (CUT)".
  </dd>
  <dt>[2]</dt><dd> The CUT interacts with the hardware through the `Led.h` interface. This interface abstracts the LEDs and is all that the CUT needs to "know" about the hardware.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
@anchor qutest_mock-unity
<strong>Left: Unity testing framework (traditional approach)</strong>
<dl class="tag">

  <dt>[3]</dt><dd> The `TestLedBar.c` file implements the Unity test fixture, which calls the CUT and verifies that it performs as expected.

> <b>NOTE:</b> A Unity test fixture for a mock requires a special "test runner", which initializes and cleans up after the mock. This "test runner" must typically be generated automatically, as it is too complex to code manually.
  </dd>
  <dt>[4]</dt><dd>
The Unity test fixture uses the `MockLed.c` implementation of the `Led.h` interface. The mock object implemented in `MockLed.c` needs to be "programmed" for each expected scenario **before** calling the CUT. Thus the structure of conventional tests with a mock is "backwards", meaning that you first specify the expectations and the test ends with a call to the CUT.

> <b>NOTE:</b> This mock-object must typically be generated automatically, as it is too complex to code manually. Here, the mock- object was generated by means of the <a href="http://www.throwtheswitch.org/cmock/" target="_blank" class="extern"><b>CMock tool</b></a>.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<strong>Right: QUTest testing framework (simplified approach)</strong>
<dl class="tag">

  <dt>[5]</dt><dd> The `test_LedBar.c` file implements the @ref qutest_mock-fixture "QUTest test fixture", which calls the CUT, but it does **NOT** check whether it performs as expected.
  </dd>
  <dt>[6]</dt><dd>
The QUTest test fixture uses the `spy_Led.c` implementation of the `Led.h` interface. This spy test double is much simpler than mock-object used by Unity, so it can easily be @ref qutest_mock-spy "coded manually".
  </dd>
  <dt>[7]</dt><dd>
The QUTest test is driven by the `test_LedBar.py` @ref qutest_mock-script "test script". This test script sends commands to the `test_LedBar.c` fixture and verifies the generated output against the expectations of the test.
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_mock-run0 Running the Test with Unity
The complete code for the mock Unity example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_mock\test_unity`</span>. To run the mock Unity test (on Windows), open a command-prompt and type:
@verbatim
cd C:\qp\qpc\examples\qutest\unity_mock\test_unity
make
@endverbatim

@note
The provided `Makefile` will also work on Linux and MacOS. The only difference from Winows is that you open a terminal window and change directory to <span class="img folder">`~/qp/qpc/examples/qutest/unity_mock/test_unity`</span>.


This will build the @ref qutest_mock-fixture "test fixture" as a host executable and then it will run it. The screen shot below shows the output produced from the make command.

![Unity mock test build and run with Unity](unity_mock_unity.png)


------------------------------------------------------------------------------
@section qutest_mock-run Running the Test with QUTest
The complete code for the mock Unity example is provided in the QP/C framework, directory <span class="img folder">`C:\qp\qpc\examples\qutest\unity_mock\test`</span>. To run the mock test (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY host utility" with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open a **second** command prompt window and type:

@verbatim
cd C:\qp\qpc\examples\qutest\unity_mock\test
make
@endverbatim

@note
The provided `Makefile` will also work on Linux and MacOS. The only difference from Windows is that you open a terminal window and change directory to <span class="img folder">`~/qp/qpc/examples/qutest/unity_mock/test`</span>.


This will build the @ref qutest_mock-fixture "test fixture" as a host executable and then it will run the @ref qutest_mock-script "test script" (in Python). The screen shot below shows the output produced in these two command-prompt windows.

![Unity mock test build and run with QUTest (left) and QSPY output (right).](unity_mock_qutest.png)


------------------------------------------------------------------------------
@section qutest_mock-spy Spy Object (Mock Replacement)
The following listing shows the "spy-object" (file <span class="img file_c">`spy_Led.c`</span>) test-double for the low-level LED module. The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
 [1] #include "qpc.h"  /* QUTest interface */
 [2] #include "Led.h"  /* original interface */

     //Q_DEFINE_THIS_FILE

     enum {
 [3]     LED_MOD = QS_USER1 /* QS app-specific record for the LED module */
     };

 [4] static uint32_t led_power[MAX_LED] = {
         10, 20, 10, 20, 10
     };

     /*--------------------------------------------------------------------------*/
 [5] void Led_DICTIONARY(void) {
         QS_FUN_DICTIONARY(&Led_on);
         QS_FUN_DICTIONARY(&Led_off);
         QS_USR_DICTIONARY(LED_MOD);
         QS_OBJ_DICTIONARY(&led_power);
     }

     /*--------------------------------------------------------------------------*/
     /* turns a given LED off */
 [6] void Led_off(uint8_t index) {
         QS_BEGIN(LED_MOD, (void *)0) /* user-specific record */
             QS_FUN(&Led_off); /* function called */
             QS_U8 (0, index); /* parameter */
         QS_END()
     }

     /* turns a given LED on and retruns the power drawn by it in uW */
 [7] uint32_t Led_on(uint8_t index) {
 [8]     uint32_t ret = led_power[index]; /* assume default power */
 [9]     QS_TEST_PROBE_DEF(&Led_on)

         /* tweak the returned power draw from the test probe */
[10]     QS_TEST_PROBE(
[11]         ret = (uint32_t)qs_tp_;
         )

[12]     QS_BEGIN(LED_MOD, (void *)0) /* user-specific record */
             QS_FUN(&Led_on);  /* function called */
             QS_U32(0, ret);   /* value returned */
             QS_U8 (0, index); /* parameter */
         QS_END()

[13]     return ret;
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file includes the QP/C framework, which contains the QUTest interface. Typically, you need to include this header file in QUTest test doubles.
  </dd>
  <dt>[2]</dt><dd> The `"Led.h"` header file specifies the interface to the code being impersonated by this "spy-object". The whole purpose of the spy-object is to implement this interface such that the CUT can call use it as its collaborator.

> <b>NOTE:</b> The CUT does not "know" that it is collaborating with a _test double_ (the spy-object in this case).
  <dt>[3]</dt><dd> This enumeration lists the @ref qs_app "application-specific QS trace records" that will be produced by the fake LED operations. The enumeration starts with #QS_USER1 offset, which is the second group of user-specific records. The first group (#QS_USER0 offset) is used by the main @ref qutest_mock-fixture "test fixture".
  </dd>
  <dt>[4]</dt><dd> The `led_power[]` array contains the default power ratings for the individual LEDs in the LED-bar. These values will be returned from the fake `Led_on()` implementation (if not overridden by the "Test Probe").
  </dd>
  <dt>[5]</dt><dd> The `Led_DICTIONARY()` function produced the dictionaries for the spy-object. This function is not part of the real LED interface (see `Led.h` in the `src` directory), but is needed only for testing.
  </dd>
  <dt>[6]</dt><dd> This is a fake `Led_off()` implementation, which generates an @ref qs_app "application-specific QS trace record" to report the call and the parameter to QSPY.
  </dd>
  <dt>[7]</dt><dd> This is a fake `Led_on()` implementation.
  </dd>
  <dt>[8]</dt><dd> The `ret` variable will be the power rating for this LED returned from this function. The variable is initialized from the `led_power[]` array, which contains the default power rating for the LEDs.
  </dd>
  <dt>[9]</dt><dd> The macro `QS_TEST_PROBE_DEF()` defines a @ref qutest_fixture-probe "Test Probe" for this function (notice the @c &Led_on function-pointer parameter). This Test Probe retreives a value set for this function from the test-script. (If no value has been set, the `QS_TEST_PROBE_DEF()` retreives value 0).
  </dd>
  <dt>[10]</dt><dd> The `QS_TEST_PROBE()` macro executes the enclosed snipped of code only if the Test Probe (defined at label [9]) is not zero.
  </dd>
  <dt>[11]</dt><dd> If the Test Probe is not zero (it has been set from the test script), the `ret` value is updated from the value of the Test Probe `qs_tp_`.

> <b>NOTE:</b> this demonstrates how to program a **return value** in a spy-object. This corresponds directly to the same capability of traditional mock-objects.


> <b>NOTE:</b> Test Probe is just one way in which a pre-programmed value can be returned from a fake function. This option is illustrated in @ref qutest_mock-script25 "test script [25]". Another way in QUTest is to use the poke() test command to alter the values in the `led_power[]` array. This option is illustrated in @ref qutest_mock-script21 "test script [21]"
  </dd>
  <dt>[12]</dt><dd> An @ref qs_app "application-specific QS trace record" is generated to report the call, the parameter, and the return value to QSPY.
  </dd>
  <dt>[13]</dt><dd> The `ret` value is returned to the caller (CUT).
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_mock-fixture Test Fixture
The following listing shows the test fixture for the LedBar tests (file <span class="img file_c">`test_LedBar.c`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
 [1] #include "qpc.h"  /* QUTest interface */
 [2] #include "LedBar.h" /* CUT interface */

     Q_DEFINE_THIS_FILE

     /*--------------------------------------------------------------------------*/
 [3] void Led_DICTIONARY(void); /* dictionaries for the Led "spy " test double */

     /*--------------------------------------------------------------------------*/
     int main(int argc, char *argv[]) {

 [4]     QF_init();  /* initialize the framework */

         /* initialize the QS software tracing */
 [5]     Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

         /* dictionaries... */
 [6]     Led_DICTIONARY();
 [7]     QS_FUN_DICTIONARY(&LedBar_setPercent);

         /* filter setup... */
 [8]     QS_FILTER_ON(QS_ALL_RECORDS);

 [9]     return QF_run(); /* run the tests */
     }

     /*--------------------------------------------------------------------------*/
     void QS_onTestSetup(void) {
     }
     /*..........................................................................*/
     void QS_onTestTeardown(void) {
     }

     /*..........................................................................*/
     void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         switch (cmdId) {
[10]         case 0: { /* call the CUT: LedBar_setPercent */
[11]             uint32_t ret = LedBar_setPercent((uint8_t)param1);
[12]             QS_BEGIN(QS_USER + cmdId, (void *)0) /* user-specific record */
[13]                 QS_FUN(&LedBar_setPercent); /* function called */
[14]                 QS_U32(0, ret); /* value returned */
[15]                 QS_U8 (0, (uint8_t)param1); /* parameter */
                 QS_END()
                 break;
             }
             default:
                 break;
         }

         /* unused parametrers... */
         //(void)param1;
         (void)param2;
         (void)param3;
     }
     /*..........................................................................*/
     /* host callback function to "massage" the event, if necessary */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     #ifdef Q_HOST  /* is this test compiled for a desktop Host computer? */
     #else /* this test is compiled for an embedded Target system */
     #endif
     }
     /*..........................................................................*/
     /*! callback function to output the posted QP events (not used here) */
     void QS_onTestPost(void const *sender, QActive *recipient,
                        QEvt const *e, bool status)
     {
         (void)sender;
         (void)recipient;
         (void)e;
         (void)status;
     }
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The `"qpc.h"` header file includes the [QP/C framework](https://www.state-machine.com/qpc/), which contains the QUTest interface. Typically, you need to include this header file in QUTest test doubles.
> **NOTE:** for test fixtures based on the [QP/C++ framework](https://www.state-machine.com/qpcpp/), you need to include the `"qpcpp.h"` header file.
  </dd>
  <dt>[2]</dt><dd> The `"LedBar.h"` header file specifies the interface to the CUT.
  </dd>
  <dt>[3]</dt><dd> The `Led_DICTIONARY()` function prototype is declared directly in the test fixture. This is the only extension from the `"Led.h"` interface implemented in the @ref qutest_mock-spy "spy-object".
  </dd>
  <dt>[4]</dt><dd> As usual the `main()` funciton of the test fixture initialzies the QF framework.
  </dd>
  <dt>[5]</dt><dd> As usual the `main()` funciton of the test fixture initalizes the QS software tracing.
  </dd>
  <dt>[6]</dt><dd> The call to the `Led_DICTIONARY()` funciton outputs the @ref qs_dict "QS dictionaries" for the @ref qutest_mock-spy "spy-object".
  </dd>
  <dt>[7]</dt><dd> The @ref qs_dict "QS dictionary" for the  `LedBar_setPercentn()` CUT is produced as well.
  </dd>
  <dt>[8]</dt><dd> The @ref qs_global "QS global filter" is set up to output all QS records.
  </dd>
  <dt>[9]</dt><dd> The `QF_run()` funciton enters the event loop to wait for commands from the @ref qutest_mock-script "test script".
  </dd>
</dl>
<div style="clear:both;"></div>


------------------------------------------------------------------------------
@section qutest_mock-script Test Script
The following listing shows the *test script* for the LedBar tests (file <span class="img file_py">`test_LedBar.py`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@note
The following test script performs the same tests as the `TestLedBar.c` Unity test fixture. Compared to the mock-object approach, however, the QUTest test script has the more intuitive structure in which a command triggering CUT is **followed** by the expecations. In contrast, the traditional @ref qutest_mock-unity "Unity tests with mock-object" were structured "backwards" (the expectations **preceeded** the call to CUT).

@code{py}
 [1] # preambe...

     # tests...
 [2] test("LedBar 0% all off")
 [3] command(0, 0)
 [4] expect("@timestamp LED_MOD Led_off 0")
     expect("@timestamp LED_MOD Led_off 1")
     expect("@timestamp LED_MOD Led_off 2")
     expect("@timestamp LED_MOD Led_off 3")
     expect("@timestamp LED_MOD Led_off 4")
 [5] expect("@timestamp USER+000 LedBar_setPercent 0 0")
 [6] expect("@timestamp Trg-Done QS_RX_COMMAND")

 [7] test("LedBar 100% all on", NORESET)
 [8] command(0, 100)
 [9] expect("@timestamp LED_MOD Led_on 10 0")
     expect("@timestamp LED_MOD Led_on 20 1")
     expect("@timestamp LED_MOD Led_on 10 2")
     expect("@timestamp LED_MOD Led_on 20 3")
     expect("@timestamp LED_MOD Led_on 10 4")
[10] expect("@timestamp USER+000 LedBar_setPercent 70 100")
[11] expect("@timestamp Trg-Done QS_RX_COMMAND")

[12] test("LedBar 19% all off", NORESET)
[13] command(0, 19)
[14] expect("@timestamp LED_MOD Led_off 0")
     expect("@timestamp LED_MOD Led_off 1")
     expect("@timestamp LED_MOD Led_off 2")
     expect("@timestamp LED_MOD Led_off 3")
     expect("@timestamp LED_MOD Led_off 4")
[15] expect("@timestamp USER+000 LedBar_setPercent 0 19")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

[16] test("LedBar 20% one on", NORESET)
[17] command(0, 20)
     expect("@timestamp LED_MOD Led_on 10 0")
     expect("@timestamp LED_MOD Led_off 1")
     expect("@timestamp LED_MOD Led_off 2")
     expect("@timestamp LED_MOD Led_off 3")
     expect("@timestamp LED_MOD Led_off 4")
[18] expect("@timestamp USER+000 LedBar_setPercent 10 20")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

[19] test("LedBar 50% two on", NORESET)
[20] current_obj(OBJ_AP, "led_power")
[21] poke(0, 4, pack("<LL", 25, 15))
[22] command(0, 50)
     expect("@timestamp LED_MOD Led_on 25 0")
     expect("@timestamp LED_MOD Led_on 15 1")
     expect("@timestamp LED_MOD Led_off 2")
     expect("@timestamp LED_MOD Led_off 3")
     expect("@timestamp LED_MOD Led_off 4")
[23] expect("@timestamp USER+000 LedBar_setPercent 40 50")
     expect("@timestamp Trg-Done QS_RX_COMMAND")

[24] test("LedBar 99% four on", NORESET)
[25] probe("Led_on", 17)
[26] probe("Led_on", 13)
[27] command(0, 99)
[28] expect("@timestamp TstProbe Fun=Led_on,Data=17")
[29] expect("@timestamp LED_MOD Led_on 17 0")
[30] expect("@timestamp TstProbe Fun=Led_on,Data=13")
[31] expect("@timestamp LED_MOD Led_on 13 1")
     expect("@timestamp LED_MOD Led_on 10 2")
     expect("@timestamp LED_MOD Led_on 20 3")
     expect("@timestamp LED_MOD Led_off 4")
[32] expect("@timestamp USER+000 LedBar_setPercent 60 99")
     expect("@timestamp Trg-Done QS_RX_COMMAND")
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The preamble is empty, because no special actionas are needed on reset/setup/teardown.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "LedBar 0% all off"</b> checks that that all LEDs are turned off to display 0%
<dl class="tag">
  <dt>[2]</dt><dd> The test() command starts the test
  </dd>
  <dt>[3]</dt><dd> The @ref command() "command(0, 0)" calls the `LedBar_setPercent()` CUT with the 0 percent argument.
  </dd>
  <dt>[4]</dt><dd> This expect() command verifies the output produced by calling the `LED_off()` function from the spy-object.
  </dd>
  <dt>[5]</dt><dd> This expect() command verifies the output produced by calling the `LedBar_setPercent()` function from the CUT. Note that the returned total power consumption is zero.
  </dd>
  <dt>[6]</dt><dd> This expect() command verifies that all output from the origianl @ref command() "command(0, 0)" has been produced.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "LedBar 100% all on"</b> checks that that all LEDs are turned on to display 100%
<dl class="tag">
  <dt>[8]</dt><dd> The test() command starts the test
  </dd>
  <dt>[9]</dt><dd> The @ref command() "command(0, 100)" calls the `LedBar_setPercent()` CUT with the 100 percent argument.
  </dd>
  <dt>[10]</dt><dd> This expect() command verifies the output produced by calling the `LedBar_setPercent()` function from the CUT. Note that the returned total power consumption is 70.
  </dd>
  <dt>[11]</dt><dd> This expect() command verifies that all output from the origianl @ref command() "command(0, 100)" has been produced.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "LedBar 19% all off"</b> checks that that all LEDs are turned off to display 19%
<dl class="tag">
  <dt>[12]</dt><dd> The test() command starts the test (NOTE: this is a NORESET test)
  </dd>
  <dt>[13]</dt><dd> The @ref command() "command(0, 19)" calls the `LedBar_setPercent()` CUT with the 19 percent argument.
  </dd>
  <dt>[14]</dt><dd> This expect() command verifies the output produced by calling the `LED_off()` function from the spy-object.
  </dd>
  <dt>[15]</dt><dd> This expect() command verifies the output produced by calling the `LedBar_setPercent()` function from the CUT. Note that the returned total power consumption is 0.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "LedBar 20% one on"</b> checks that that all LEDs are turned off to display 20%
<dl class="tag">
  <dt>[16]</dt><dd> The test() command starts the test (NOTE: this is a NORESET test)
  </dd>
  <dt>[17]</dt><dd> The @ref command() "command(0, 20)" calls the `LedBar_setPercent()` CUT with the 20 percent argument.
  </dd>
  <dt>[18]</dt><dd> This expect() command verifies the output produced by calling the `LedBar_setPercent()` function from the CUT. Note that the returned total power consumption is 10.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "LedBar 50% two on"</b> checks that that two LEDs is turned on to display 50%
<dl class="tag">
  <dt>[19]</dt><dd> The test() command starts the test (NOTE: this is a NORESET test)
  </dd>
  <dt>[20]</dt><dd> The @ref current_obj() "current_obj(OBJ_AP, "led_power")" command sets the "current application object" to "led_power" (see @ref qutest_mock-spy "spy-object"[4]).
  </dd>
  <dt>[21]</dt>
@anchor qutest_mock-script21
  <dd> The @ref poke() "poke(0, 4, pack("<LL", 25, 15))" command pokes the given data into the "current application object". Specifically, this poke() command pokes the data starting from offset 0, data-size 4, binary-data `pack("<LL", 25, 15)`.
  </dd>
  <dt>[22]</dt><dd> The @ref command() "command(0, 50)" calls the `LedBar_setPercent()` CUT with the 50 percent argument.
  </dd>
  <dt>[23]</dt><dd> This expect() command verifies the output produced by calling the `LedBar_setPercent()` function from the CUT. Note that the returned total power consumption is 40, which is due to poking the data into the `led_power` array.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "LedBar 99% two on"</b> checks that that two LEDs is turned on to display 99%
<dl class="tag">
  <dt>[24]</dt><dd> The test() command starts the test (NOTE: this is a NORESET test)
  </dd>
  <dt>[25]</dt>
@anchor qutest_mock-script25
  <dd> The @ref probe() "probe("Led_on", 17)" command sends the @ref qutest_fixture-probe "test-probe" value 17 for function `Led_on`
  </dd>
  <dt>[26]</dt><dd> The @ref probe() "probe("Led_on", 13)" command sends another the @ref qutest_fixture-probe "test-probe" value 13 for function `Led_on`
  </dd>
  <dt>[27]</dt><dd> The @ref command() "command(0, 99)" calls the `LedBar_setPercent()` CUT with the 99 percent argument.
  </dd>
  <dt>[28]</dt><dd> This expect() command verifies the test-probe sent at step [25] has been retreived.
  </dd>
  <dt>[29]</dt><dd> This expect() command verifies the function `Led_on` has been called, and that it returned 17.
  </dd>
  <dt>[30]</dt><dd> This expect() command verifies the test-probe sent at step [26] has been retreived.
  </dd>
  <dt>[31]</dt><dd> This expect() command verifies the function `Led_on` has been called, and that it returned 13.
  </dd>
  <dt>[32]</dt><dd> This expect() command verifies the output produced by calling the `LedBar_setPercent()` function from the CUT. Note that the returned total power consumption is 60, which is due to using test-probes to alter the return values returned from `Led_on()`.
  </dd>
</dl>
<div style="clear:both;"></div>

@next{qutest_qhsm}
*/

/*###########################################################################*/
/*! @page qutest_qhsm Hierarchical State Machine Example

@tableofcontents
<p>This example shows how to apply QUTest for unit-testing [Hierarchical State Machines](https://www.state-machine.com/doc/concepts.php#HSM). This example illustrates two testing strategies for state machines:
</p>

- **Functional tests** focus on the *actions* performed by the state machine.

> <b>NOTE:</b> As described in the @ref qutest_mock, testing of complex, multi-stage interactions (such as a state machine) typically requires application of a "mock object" test double. However, the QUTest design philosophy allows you to use much simpler "spy object" test double instead. The **functional testing** strategy illustrates this approach.

- **Structural tests** focus on the state machine structure, such as entering/exiting *states* and executing *state transitions*.

> <b>NOTE:</b> Unlike the previous examples (@ref qutest_unity "Unity-basic" and @ref qutest_mock "Unity-mock"), which pertained to generic C code, the **structural testing** of state machine makes use of the specific state machine instrumentation that is provided in QP.

@remark
In practice, unit-testing of state machines typically involves a mixture of functional and structural testing strategies.


------------------------------------------------------------------------------
@section qutest_qhsm-cut  Code Under Test (CUT)
This example is available in both [<b>QP/C</b>](https://www.state-machine.com/qpc) as well as in [<b>QP/C++</b>](https://www.state-machine.com/qpcpp) frameworks.The complete code for the `qhsm` example is provided in the directory <span class="img folder">`<qpc|qpcpp>\examples\qutest\qhsmtst`</span>.

The hierarchical state machine used in this example is artificial, but it has been specifically designed to contain all possible state transition topologies for up to 4 levels of state nesting. The code representing this state machine  (the CUT here), has been generated automatically by the [QM modeling tool](https://www.state-machine.com/qm/) from the model shown in the screen-shot below:

![QHsmTst state machine in QM](qhsmtst_qm.png)

The state machine executes actions on every entry/exit to states, on state transitions and on internal state transitions. These actions are all implemented by calling the `BSP_display()` function that outputs a succinct message about the location of the action within the state machine. For example, the entry action to state "s2" calls `BSP_display("s2-ENTRY;")` and the exit action from state "s2" calls `BSP_display("s2-EXIT;")`. These actions then are used for @ref qutest_qhsm-funct-script "functional testing" of the state machine.


------------------------------------------------------------------------------
@section qutest_qhsm-run Running the Test
To run the `qhsm` tests (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY" host application with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open another command prompt window and type:

@verbatim
cd C:\qp\<qpc|qpcpp>\examples\qutest\qhsmtst\test
make
@endverbatim

This will build the @ref qutest_qhsm-fixture "test fixture" as a Windows executable and then it will run the @ref qutest_qhsm-funct-script "test script". The screen shot below shows the output produced in these two command-prompt windows.

![QUTest QHsm test run](test_qhsm.png)


------------------------------------------------------------------------------
@section qutest_qhsm-fixture Test Fixture
The following listing shows the test fixture for the QHsm tests (file <span class="img file_c">`test_qhsm.c`</span>). This test fixture is used in both @ref qutest_qhsm-funct-script "functional" and @ref qutest_qhsm-struct-script "structural" tests. The explanation section following the listing clarifies the interesting lines of code (lines starting with [xx] labels).

@code
     #include "qpc.h"       /* QUTest interface */
     #include "qhsmtst.h"   /* CUT */

     Q_DEFINE_THIS_FILE

     enum {
 [1]     BSP_DISPLAY = QS_USER,
     };

     /*--------------------------------------------------------------------------*/
     int main(int argc, char *argv[]) {
         static QF_MPOOL_EL(QEvt) smlPoolSto[10]; /* small pool */

         QF_init();    /* initialize the framework */

         /* initialize the QS software tracing */
         Q_ALLEGE(QS_INIT(argc > 1 ? argv[1] : (void *)0));

         /* initialize event pools... */
         QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(smlPoolSto[0]));

         /* dictionaries... */
 [2]     QS_FUN_DICTIONARY(&QHsm_top);
 [3]     QS_OBJ_DICTIONARY(the_hsm);
 [4]     QS_USR_DICTIONARY(BSP_DISPLAY);

 [5]     QHsmTst_ctor(); /* instantiate the QHsmTst object */

         return QF_run();
     }

     /*--------------------------------------------------------------------------*/
 [6] void BSP_display(char const *msg) {
 [7]     QS_BEGIN(BSP_DISPLAY, (void *)0) /* application-specific record */
 [8]         QS_STR(msg);
         QS_END()
     }

     /*..........................................................................*/
     void BSP_exit(void) {
     }

     /*--------------------------------------------------------------------------*/
     void QS_onTestSetup(void) {
     }
     /*..........................................................................*/
     void QS_onTestTeardown(void) {
     }
     /*..........................................................................*/
     void QS_onCommand(uint8_t cmdId,
                       uint32_t param1, uint32_t param2, uint32_t param3)
     {
         (void)param1;
         (void)param2;
         (void)param3;

         switch (cmdId) {
            case 0U: {
                break;
            }
            default:
                break;
         }
     }

     /*..........................................................................*/
     #ifdef Q_HOST  /* is this test compiled for a desktop Host computer? */
     /*! host callback function to "massage" the event, if necessary */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
     #else /* this test is compiled for an embedded Target system */
     void QS_onTestEvt(QEvt *e) {
         (void)e;
     }
     #endif
@endcode
<dl class="tag">
  <dt>[1]</dt><dd> The `BSP_DISPLAY` enumeration will be used as the record-ID for the @ref qs_app "application-specific trace record".
  </dd>
> **NOTE:** The record-ID is offset by #QS_USER.
  <dt>[2]</dt><dd> This line produces a @ref qs_dict "function dictionary" for the [QHsm_top() function](https://www.state-machine.com/qpc/qep_8h.html#ac8ae4728dfab5ce26a907fc624f6e104).
  </dd>
  <dt>[3]</dt><dd> This line produces a @ref qs_dict "object dictionary" for the `l_hsm` state machine object to test.
  </dd>
  <dt>[4]</dt><dd> This line produces a @ref qs_dict "user dictionary" for the application-specific trace record defined at label [1].
  </dd>
  <dt>[5]</dt><dd> The "constructor" of the state machine object is called.
  </dd>
> **NOTE:** The explicit "constructor" call is needed only in C. In C++ static constructors are called automatically as part of the startup sequence.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
@subsection qutest_qhsm-act Action Functions Test Doubles
For functional testing, which is focused on the **actions** performed by a state machine, the actions must generate some QS output. This QS instrumentation can be added either directly to the state machine model, or indirectly to the functions called from the state machine actions. The test fixture above illustrates the second option, because it was more convenient in this case (see `BSP_display()` implementation starting at label [6] above).

<dl class="tag">
  <dt>[6]</dt><dd> The function `BSP_display()` is called from all actions of the state machine. Inside the test fixture, this function is defined to produce QS output. This is a classic example of a "spy" test double.
  </dd>
  <dt>[7]</dt><dd> The QS output is produced with an @ref qs_app "application-specific trace record" enumerated at label [1]. The second argument to the QS_BEGIN() macro is zero, which means that this   record does not use any @ref qs_local "local filter".
  </dd>
  <dt>[8]</dt><dd> The QS_STR() data element outputs the message string.
  </dd>
</dl>
<div style="clear:both;"></div>
@n

@remark
In practice, you will likely use both functional and structural testing at the same time. Simple actions that do not perform any hardware-specific operations could be instrumented (with @ref qs_app "QS application-specific trace records") directly in the CUT (your state machines). The hardware-specific actions need to be abstracted anyway (in the BSP for "dual targeting"), in which case you can place the QS instrumentation in the BSP only.


------------------------------------------------------------------------------
@section qutest_qhsm-funct-script Test Script (Functional Testing)
The following listing shows the *test script* for the QHsm tests (file <span class="img file_py">`test_qhsm-funct.py`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code
     # preamble...
 [1] def on_reset():
 [2]    glb_filter(GRP_UA)
 [3]    current_obj(OBJ_SM, "the_hsm")

     # tests...
 [4] test("QHsmTst init")
 [5] init()
 [6] expect("@timestamp BSP_DISPLAY top-INIT;")
     expect("@timestamp BSP_DISPLAY s-ENTRY;")
     expect("@timestamp BSP_DISPLAY s2-ENTRY;")
     expect("@timestamp BSP_DISPLAY s2-INIT;")
     expect("@timestamp BSP_DISPLAY s21-ENTRY;")
     expect("@timestamp BSP_DISPLAY s211-ENTRY;")
     expect("@timestamp Trg-Done QS_RX_EVENT")

     #------------------
 [7] test("QHsmTst dispatch", NORESET)
 [8] dispatch("A_SIG")
 [9] expect("@timestamp BSP_DISPLAY s21-A;")
     expect("@timestamp BSP_DISPLAY s211-EXIT;")
     expect("@timestamp BSP_DISPLAY s21-EXIT;")
     expect("@timestamp BSP_DISPLAY s21-ENTRY;")
     expect("@timestamp BSP_DISPLAY s21-INIT;")
     expect("@timestamp BSP_DISPLAY s211-ENTRY;")
[10] expect("@timestamp Trg-Done QS_RX_EVENT")

     dispatch("B_SIG")
     expect("@timestamp BSP_DISPLAY s21-B;")
     expect("@timestamp BSP_DISPLAY s211-EXIT;")
     expect("@timestamp BSP_DISPLAY s211-ENTRY;")
     expect("@timestamp Trg-Done QS_RX_EVENT")

     ~ ~ ~
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The script procedure `on_reset()` is executed after each reset of the target. This is in contrast to the procedure `on_setup()`, which is executed at the begin of all tests, including tests that don't reset the target.
  </dd>
  <dt>[2]</dt><dd> The @ref qs_global "global filter" is set to `GRP_UA`, which means &laquo;<b>group-user-all</b>&raquo; trace records. This filter setting determines the character of the test to be a **functional** test, because the focus is on the trace records produced by actions (@ref qs_app "user-defined" records) rather than the @ref qs_pre "pre-defined records" generated by executing a state machine.
  </dd>
  <dt>[3]</dt><dd> The command current_obj() sets the current state machine object to `"the_hsm"`. Because this is performed in the on_reset() callack, this current object will be set before every test (except the NORESET-tests, which do not call on_reset()).
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "QHsmTst init"</b> tests the top-most initial transition
<dl class="tag">
  <dt>[4]</dt><dd> The test() command starts the test.
  </dd>
  <dt>[5]</dt><dd> The init() command triggers the initial transition in the current state-machine object (see label [3]).
  </dd>
  <dt>[6]</dt><dd> The following expect() commands verify that all steps of the top-most initial transition are taken in the right order.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "QHsmTst dispatch"</b> tests dispatching various events to the state machine
<dl class="tag">
  <dt>[7]</dt><dd> The test() command starts the test.
  </dd>
  <dt>[8]</dt><dd> The dispatch() command dispatches a given event to the state machine
  </dd>
  <dt>[9]</dt><dd> The expect() commands verify that the state machine **actions** (`BSP_display()` function) happened.
  </dd>
  <dt>[10]</dt><dd> This expect() command verifies that the processing of the event (see dispatch() at label [8]) has completed.
  </dd>
</dl>
<div style="clear:both;"></div>



------------------------------------------------------------------------------
@section qutest_qhsm-struct-script Test Script (Structural Testing)
The following listing shows the *test script* for the QHsm tests (file <span class="img file_py">`test_qhsm-struct.py`</span>). The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code
     # preamble...
 [1] def on_reset():
 [2]    glb_filter(GRP_SM)
 [3]    current_obj(OBJ_SM, "the_hsm")


     # tests...
 [4] test("QHsmTst init")
 [5] init()
 [6] expect("===RTC===> St-Init  Obj=the_hsm,State=QHsm_top->QHsmTst_s2")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s2")
     expect("===RTC===> St-Init  Obj=the_hsm,State=QHsmTst_s2->QHsmTst_s211")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s21")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s211")
     expect("@timestamp Init===> Obj=the_hsm,State=QHsmTst_s211")
     expect("@timestamp Trg-Done QS_RX_EVENT")

     #------------------
 [7] test("QHsmTst dispatch", NORESET)
 [8] dispatch("A_SIG")
 [9] expect("@timestamp Disp===> Obj=the_hsm,Sig=A_SIG,State=QHsmTst_s211")
     expect("===RTC===> St-Exit  Obj=the_hsm,State=QHsmTst_s211")
     expect("===RTC===> St-Exit  Obj=the_hsm,State=QHsmTst_s21")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s21")
     expect("===RTC===> St-Init  Obj=the_hsm,State=QHsmTst_s21->QHsmTst_s211")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s211")
     expect("@timestamp ===>Tran Obj=the_hsm,Sig=A_SIG,State=QHsmTst_s21->QHsmTst_s211")
[10] expect("@timestamp Trg-Done QS_RX_EVENT")

     dispatch("B_SIG")
     expect("@timestamp Disp===> Obj=the_hsm,Sig=B_SIG,State=QHsmTst_s211")
     expect("===RTC===> St-Exit  Obj=the_hsm,State=QHsmTst_s211")
     expect("===RTC===> St-Entry Obj=the_hsm,State=QHsmTst_s211")
     expect("@timestamp ===>Tran Obj=the_hsm,Sig=B_SIG,State=QHsmTst_s21->QHsmTst_s211")
     expect("@timestamp Trg-Done QS_RX_EVENT")

     ~ ~ ~
@endcode

<dl class="tag">
  <dt>[1]</dt><dd> The script procedure `on_reset()` is executed after each reset of the target. This is in contrast to the procedure `on_setup()`, which is executed at the begin of all tests, including tests that don't reset the target.
  </dd>
  <dt>[2]</dt><dd> The @ref qs_global "global filter" is set to `GRP_SM`, which means &laquo;<b>group-state-machine</b>&raquo; trace records. This filter setting determines the character of the test to be a **structural** test, because the focus is on the @ref qs_pre "pre-defined records" generated by executing a state machine, rather than trace records produced by actions (user trace records).
  </dd>
  <dt>[3]</dt><dd> The command current_obj() sets the current state machine object to `"the_hsm"`. Because this is performed in the on_reset() callack, this current object will be set before every test (except the NORESET-tests, which do not call on_reset()).
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "QHsmTst init"</b> tests the top-most initial transition
<dl class="tag">
  <dt>[4]</dt><dd> The test() command starts the test.
  </dd>
  <dt>[5]</dt><dd> The init() command triggers the initial transition in the current state-machine object (see label [3]).
  </dd>
  <dt>[6]</dt><dd> The following expect() commands verify that all steps of the top-most initial transition are taken in the right order.
  </dd>
</dl>
<div style="clear:both;"></div>

<div class="separate"></div>
<b>Test: "QHsmTst dispatch"</b> tests dispatching various events to the state machine
<dl class="tag">
  <dt>[7]</dt><dd> The test() command starts the test.
  </dd>
  <dt>[8]</dt><dd> The dispatch() command dispatches a given event to the state machine
  </dd>
  <dt>[9]</dt><dd> The expect() commands verify that the state machine RTC (Run-To-Completion) steps have been executed.
  </dd>
  <dt>[10]</dt><dd> This expect() command verifies that the processing of the event (see dispatch() at label [8]) has completed.
  </dd>
</dl>
<div style="clear:both;"></div>

@next{qutest_blinky}
*/

/*###########################################################################*/
/*! @page qutest_blinky Blinky Example

@tableofcontents

<p>This example shows how to unit-test a simple active object (AO) called "Blinky". This Blinky AO turns on and off an LED, which is driven by a [<b>QP time event</b>](https://www.state-machine.com/qpc/qf_8h.html#struct_q_time_evt).
</p>


------------------------------------------------------------------------------
@section qutest_blinky-cut Code Under Test (CUT)
This example is available in both [<b>QP/C</b>](https://www.state-machine.com/qpc) as well as in [<b>QP/C++</b>](https://www.state-machine.com/qpcpp) frameworks. The complete code for the Blinky example is provided in the directory <span class="img folder">`<qpc|qpcpp>\examples\qutest\blinky\test`</span>.

![Blinky model in QM.](qutest_blinky_qm.png)


------------------------------------------------------------------------------
@section qutest_blinky-run Running the Test with QUTest
To run the `Blinky` test (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY host utility" with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open a **second** command prompt window and type:

@verbatim
cd C:\qp\<qpc|qpcpp>\examples\qutest\blinky\test
make
@endverbatim

@note
The provided `Makefile` will also work on Linux and MacOS. The only difference from Windows is that you open a terminal window and change directory to <span class="img folder">`~/qp/<qpc|qpcpp>/examples/qutest/blinky/test`</span>.


This will build the @ref qutest_blinky-fixture "test fixture" as a host executable and then it will run the @ref qutest_blinky-script "test script" (in Python). The screen shot below shows the output produced in these two command-prompt windows.

![Blinky test build and run with QUTest (left) and QSPY output (right).](test_blinky.png)



@next{qutest_dpp}
*/

/*###########################################################################*/
/*! @page qutest_dpp DPP Example

@tableofcontents

<p>The DPP (Dining Philosopher Problem) example shows how to use QUTest in various stages of application development, including not only unit testing, but also **integration testing** as well.
</p>


------------------------------------------------------------------------------
@section qutest_dpp-cut  Code Under Test (CUT)
This example is available in both [<b>QP/C</b>](https://www.state-machine.com/qpc) as well as in [<b>QP/C++</b>](https://www.state-machine.com/qpcpp) frameworks. The complete code for the DPP example is provided in the directory <span class="img folder">`<qpc|qpcpp>\examples\qutest\dpp\test`</span>.


------------------------------------------------------------------------------
@section qutest_dpp-run Running the Test with QUTest
To run the DPP test (on Windows), open a command prompt and type:

@verbatim
qspy -u -t
@endverbatim

This will start the @ref qspy "QSPY host utility" with the UDP socket (`-u` @ref qspy_command "option") and TCP/IP connection to the Target (`-t` @ref qspy_command "option").

Next, open a **second** command prompt window and type:

@verbatim
cd C:\qp\<qpc|qpcpp>\examples\qutest\dpp\test_philo
make
@endverbatim

@note
The provided `Makefile` will also work on Linux and MacOS. The only difference from Windows is that you open a terminal window and change directory to <span class="img folder">`~/qp/<qpc|qpcpp>/examples/qutest/blinky/test`</span>.


This will build the @ref qutest_blinky-fixture "test fixture" as a host executable and then it will run the @ref qutest_blinky-script "test script" (in Python). The screen shot below shows the output produced in these two command-prompt windows.

![DPP test build and run with QUTest (left) and QSPY output (right).](test_dpp.png)


@next{qutest_rtc}
*/

