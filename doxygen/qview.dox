/*! @page qview QView&trade; Visualization &amp; Monitoring

![](qview_banner.jpg)

@subpage qview_ui "&nbsp;"
@subpage qview_cust "&nbsp;"


@section qview_about About QView&trade;

@htmlonly
<img style="float:right; margin:10px 8px 8px 15px; clear:right;" src="img/logo_python3.gif" title="Python3">
@endhtmlonly

<p>QView&trade; is a powerful **Visualization and Monitoring** facility, which allows embedded developers to rapidly create **remote graphical user-interfaces** to monitor and control their embedded devices from a host (desktop) computer. The interfaces created by QView&trade; can visualize the tracing data produced by @ref qpspy "QP/Spy" and can also **interact with the target** by sending commands and injecting events to the embedded target.
</p>

As you can see in the screen shots below, a QView&trade; user interface consists of the text box with extensible menus plus a **customizable canvas** that can serve as a remote graphical user-interface to your embedded device. The canvas can contain various "widgets", such as buttons, sliders, guages, graphs, animations etc. The actual functionality of the _virtual GUI_ obviously depends on the target system and the embedded code it is running. Therefore, the QView&trade; provides only a skeleton, which is then @ref qview_cust "customized" by user-supplied scripts written in <a href="https://www.python.org" class="extern"><b>Python</b></a> (version 3).

<div style="clear:both;"></div>

@image html qview_ex.gif "Example of a QView&trade; session on an embedded board (Windows host)"

@n
@image html qview_dpp-fedora.gif "Example of a QView&trade; session (Linux host)"


@subsection qview_special What's Special About It?

QView&trade; has been specifically designed for extensibility, so that you can quickly @ref qview_cust "customize its GUI and behavior" to your specific embedded project, so that you can use QView&trade; as a powerful custom Human-Machine Interface (HMI) for your projects. The cusomization is accomplished in <a href="https://www.python.org" class="extern"><b>Python</b></a> (version 3), which means that it is naturally platform-neutral and runs without any changes on Windows, Linux, or macOS.

Out of the box, QView&trade; supports the following @ref qview_ui "commands" (<strong>NOTE:</strong> This basic functionality can be extended in the @ref qview_cust "QView&trade; customization"):

- Set @ref qs_global "global QS filters" inside the Target
- Set @ref qs_local "local QS filters" inside the Target
- Inject an arbitrary event to the Target (direct post or publish)
- Execute a user-defined command function inside the Target with arguments supplied from QView&trade;
- Peek data inside the Target and send to QView&trade;
- Poke data (supplied from QView&trade;) into the Target
- Execute clock tick inside the Target
- Remotely reset the Target

@note
A visualization and monitoring system like QView&trade; can be used in all stages of development, manufacturing, and after the deployment, for in-field servicing of embedded devices.


@section qview_struct QView&trade; Structure
The sequence diagram below shows the general structure of QView&trade;. The embedded Target is running an instrumented code that communicates with the @ref qspy "QSPY Host application" over the @ref qspy_link "Target data link" (<span style="color:red"><strong>red arrows</strong></span>). This communication is based on the @ref qpspy_proto "QP/Spy Protocol".

@attention
The Target must be running the "Spy" build configuration, in which the @ref qpspy is enabled. Additionally, the QP/Spy implementation in the Target must support the @ref qpspy_rx "bi-directional" communication with @ref qspy "QSPY".


The QView&trade; (Python script) attaches to the QSPY host application by means of the @ref qspy_udp "UDP socket" that QSPY opens specifically for attaching various "front-ends". This communication (<span style="color:blue"><strong>blue arrows</strong></span>) uses the same packet structure as the @ref qpspy_proto "QP/Spy Protocol", but without the HDLC framing, without transparency (escaping), and without the checksum.


@image html qspy_qview.gif "Communication between Target, QSPY, and QView"

<dl class="tag">
  <dt>A</dt><dd> A Target produces QS trace records, which the @ref qspy "QSPY Back-End" forwards to the @ref qpspy_udp "UDP Socket", so that any attached Front-End (such as QView&trade;) receives all this data.
  </dd>

  <dt>B</dt><dd> The Front-End (QView&trade;) sends commands as @ref qpspy_udp "UDP packets to QSPY". For some of those packets, the @ref qspy "QSPY Back-End" supplies additional information (e.g., translation between symbolic names and binary addresses according to the @ref qs_dict "QS dictionaries" collected from the Target).
  </dd>

  <dt>C</dt><dd> The @ref qspy "QSPY Back-End" then forwards the modified packets to the Target.
  </dd>
</dl>
<div style="clear:both;"></div>

@remark
<strong>Why UDP?</strong> The @ref qspy_udp "communication between QSPY and QView" is based on UDP, because UDP is inherently packet-oriented (as opposed to TCP, which is stream-oriented) and preserves the <em>packet boundaries</em>.


@section qview_use Installation &amp; Use
The <span class="img file_py">qview.py</span> script can be used standalone, without any installation in your Python system (see  @ref qview_run below).

@note
The <span class="img file_py">qview.py</span> script is included in the @ref qtools_about "QTools&trade; collection". Also, the @ref qtools_win "QTools&trade; collection for Windows" already includes Python (3.8), so you don't need to install anything extra.


Alternatively, you can use *your own Python** installation, into which you can install the latest QView&trade; with `pip` from the [<b>PyPi index</b>](https://pypi.org/project/qview/) by executing the following command:

@verbatim
pip install qview
@endverbatim


@subsection qview_run Running QView&trade;
If you are using QView&trade; as a standalone Python script, you invoke it as follows:

@verbatim
python3 <path-to-qview-script>/qview.py [<cust_script> [<qspy_host> [<qspy_port>]]]
@endverbatim

Alternatively, if you've installed QView&trade; with `pip`, you invoke it as follows:

@verbatim
qview [cust_script] [qspy_host[:udp_port]] [local_port]
@endverbatim


@subsection qview_command Command-line Options
- `cust_script` - optional @ref qview_cust "customization Python script" for your specific target system. If not specified, qview will provide only the @ref qview_ui "generic user interface" for interacting with the target (e.g., reset, setting QS filters, posting events, etc.)

- `qspy_host[:udp_port]` - optional host-name/IP-address:port for the host running the QSPY host utility. If not specified, the default is 'localhost:7701'.

- `local_port` - optional the local UDP port to be used by "qview". If not specified, the default is '0', which means that the operating system will choose an open port.


@subsection qview_exa Examples

<span class="logo logo_win">Windows Hosts</span>

@verbatim
python3 %QTOOLS%\qview\qview.py
@endverbatim

opens the generic (not customized) "qview".

@verbatim
python3 %QTOOLS%\qview\qview.py dpp.py
@endverbatim

opens "qview" with the customization provided in the dpp.py script located in the current directory.

@verbatim
qview ..\qview\dpp.py localhost:7701
@endverbatim

opens "qview" (**installed with pip**) with the customization provided in the dpp.py script located in the directory ..\qview. The "qview" will attach to the QSPY utility running at localhost:7701.

@verbatim
qview dpp.py 192.168.1.100:7705
@endverbatim

opens "qview" (**installed with pip**) with the customization provided in the dpp.py script located in the current directory. The "qview" will attach to the QSPY utility running remotely at IP address 192.168.1.100:7705.


<span class="logo logo_linux"></span><span class="logo logo_macos">Linux/MacOS Hosts</span>

@verbatim
python3 $(QTOOLS)/qview/qview.py
@endverbatim

opens the generic (not customized) "qview".

@verbatim
python3 $(QTOOLS)/qview/qview.py dpp.py
@endverbatim

opens "qview" with the customization provided in the dpp.py script located in the current directory.

@verbatim
qview *.py ../qview/dpp.py localhost:7701
@endverbatim

opens "qview" (**installed with pip**) with the customization provided in the dpp.py script located in the directory ../qview. The "qview" will attach to the QSPY utility running at localhost:7701.

@verbatim
qview dpp.py 192.168.1.100:7705
@endverbatim

opens "qview" (**installed with pip**) with the customization provided in the dpp.py script located in the current directory. The "qview" will attach to the QSPY utility running remotely at IP address 192.168.1.100:7705.


@note
In practice, the easiest way to launch QView&trade; is to define a <strong>shortcut</strong>, like the one provided with the DPP example:@n@n
@image html qview_shortcut.gif "qview shortcut properties"


@section qview_attaching Attaching QView to QSPY
In contrast to TCP, which is stream-oriented, UDP is packet-oriented, so the only way to "attach" two ends of communication is to exchange packets. Consequently, immediately after QView&trade; is launched, it tries to **attach** by sending the @ref udp_ATTACH "ATTACH" packet to QSPY. If QSPY responds with the @ref udp_in_ATTACH "ATTACH" response, QView&trade; considers that it is "attached".

However, if the @ref udp_in_ATTACH "ATTACH" response does not arrive within a second or two (because perhaps QSPY is not running), QView&trade; opens a modal dialog box that reminds you to run QSPY, as shown in the screen-shot below:

@image html qview_attach.gif "Attach to QSPY dialog box"
qview_before.gif
Depending how you start @ref qspy "QSPY", the dialog box might close automatically, which means that QView has successfully **attached** to QSPY. However, if the dialog box does not close, you need to click the **Attach** button to send @ref udp_ATTACH "ATTACH" packet to QSPY, until QView&trade; receives the @ref udp_in_ATTACH "ATTACH" response from QSPY. If you can't "attach", you can click the **Close** button to close QView&trade;.

@note
Because UDP works over networks, the QSPY Back-End can run on a **different machine** (e.g., a lab computer) that the the QView&trade; Front-End (e.g., office computer). These two machines can even run different operating systems, for example Linux on the lab computer and Windows in the office, or vice versa. All you need to do is to provide the host-name parameter as the <em>third</em> command-line argument to the <span class="img file_py">qview.py</span> script (e.g., `python3 qview.py dpp.py 192.168.1.101`).


@subsection qview_tstamp Recognizing the Target
Before QView&trade; can correctly interpret any data from the Target, it needs to obtain certain information about the Target, such as the sizes of object pointers, function pointers, event signals, etc. This information is provided in the ::QS_TARGET_INFO trace record coming from the Target.

To inform you about the Target status, QView&trade; displays the **Target: UNKNOWN** in the status bar when the target is "unknown":

@image html qview_unknown.gif "Target UNKNOWN status"

If this happens, you can explicitly request the Target information by means of the "Commands->Query Target Info" menu:

@image html qview_known.gif "Target KNOWN status (build time-stamp)"

After the Target information is received, the QView&trade; status bar shows the build time-stamp of the Target image.

@nav{qutest_script,qview_ui}
*/
/*###########################################################################*/
/**
@page qview_ui QView User Interface

@tableofcontents
@nav{qutest_script,qview_cust}

<p>The <span class="img file_py">qview.py</span> script provides a Graphical User Interface (GUI) consisting of the main menu, the text view, the status bar, and the customizable canvas view.
</p>

@image html qview.jpg "QView user interface"

The **main menu** includes several useful commands, which are quickly reviewed and the following sections. The main menu might subsequently be augmented in your own @ref qview_cust "customizations".



@section qview_file File Menu
The File menu provides interface to the @ref qspy_saving "QSPY saving files" feature. This menu allows you to trigger QSPY to save @ref qspy_dict "dictionaries", as well as to open/close all other file formats supported by QSPY.

@image html qview_file.gif


@section qview_view View Menu
The View menu allows you to toggle (show/hide) the Canvas view.

@image html qview_view.gif "Text-view and Canvas-view menus"

@image html qview_canvas.gif "Canvas-view enabled"

@note
The provided screen shot of the Canvas-view is specific to the DPP example application (see @ref qview_cust).


@section qview_glob Global Filters Menu
The Filters menu opens dialog boxes through which you can set the @ref qs_global "QS Global Filter" for QS Record-Types.

The Global Filter menu opens dialog boxes for each *group* of global filters. For example, the screen shot below shows the "SM Group" (State Machine Group). In this "SM Group" dialog box you can check/uncheck the individual filters, or you can "Select ALL" or "Clear ALL" filters in the group.

@image html qview_glob_dlg.gif "Global Filter SM-Group Dialog Box"

@note
The Global-Filters menu reflects the status of the whole group by the following status-indicators:
- `[-]`- no filters in the group selected
- `[+-]` - some filters in the group selected
- `[+]` - all filters in the group selected


@section qview_loc Local Filters Menu
The Filters menu opens dialog boxes through which you can set the  @ref qs_local "QS Local Filter" for QS QS-IDs.

The Local Filter menu opens dialog boxes for each *group* of local filters. For example, the screen shot below shows the "AO-IDs" (Active Object Group). In this "AO-IDs" dialog box you can check/uncheck the individual QS-IDs (which are AO priorities in this case), or you can "Select ALL" or "Clear ALL" filters in the group.

@image html qview_loc_dlg.gif "Local Filter AO_OBJ Dialog Box"

@note
The Local-Filters menu reflects the status of the whole group by the following status-indicators:
- `[-]`- no filters in the group selected
- `[+-]` - some filters in the group selected
- `[+]` - all filters in the group selected


@section qview_curr Current-Obj Menu
The Curr-Obj menu opens dialog boxes through which you can set the @ref qs_curr "QS Current Objects".

The Curr-Obj menu opens dialog boxes for each local current object. For example, the screen shot below shows the "AO_OBJ" (current Active Object). In this "Curr-Obj" dialog box you can specify the object either by its name (must match the QS dictionary), or as addresses of the objects in decimal and in hexadecimal (with the `0x` prefix).

@image html qview_curr_dlg.gif "Current Object AO_OBJ Dialog Box"

@note
The Curr-Obj menu reflects the selected current objects, which are listed to the right of the filter (e.g. `Table_inst`).


@section qview_commands Commands Menu
The Commands menu allows you to execute simple commands (without parameters) in the Target, such as Reset the Target, Query the Target, and clock Tick at rate 0 and rate 1. Also, this menu allows you to execute commands with parameters, which are quickly discussed below

@image html qview_cmd.gif "Commands Menu"


@subsection qview_user Executing User Command
The "User Command..." menu allows you to invoke a command in the Target and pass up to three parameters to this command. (**NOTE:** a command is an application-specific callback function that the QS-RX component executes in the Target).

@image html qview_cmd_dlg.gif "Command Dialog Box"

The screen shot above shows how to execute User Command number `0` with the parameters: `12345`, `0xDEADBEEF` and `0` (default). Both the command number and the parameters can be specified in hexadecimal (with the `0x` prefix).


@subsection qview_peek Peek Command
The Peek Obj/Addr... command opens a dialog box, in which you can provide the Target object or address (RAM or ROM) (**NOTE:** You can provide either the object name, which must be known by its object-dictionary, or numerical address, which **must** be a valid RAM/ROM address, or the Target might crash.)

@attention
The "Peek..." menu requires the "Current-Obj AP_OBJ" to be set in the @ref qview_curr, because this is the object within the Target which will be "peeked". The "Peek..." menu is **inactive** (grayed-out) when the "Current-Obj AP_OBJ" is not specified.


@note
The Peek Command can be used to view any **readable** address, such as ROM, RAM, and also **peripheral registers** in your Target.


As shown in the screen shot below, the PEEK command takes additionally the offset into the object [bytes] (offset of 0 is default if not specified), the size of the item [8-bit, 16-bit, 32-bit] and the number of units (n-units) [1..255] you wish to "peek".

@image html qview_cmd_peek.gif "Peek Command Dialog Box"
@n

The Target responds with a #QS_PEEK_DATA trace record, which you can view in QSPY human-readable output (the packet is also sent to QView, where you can react to it in your @ref qview_cust "customization".)

@verbatim
4294965703 Trg-Peek Offs=0,Size=4,Num=4,Data=<20000D2C,20000D2C,20000D74,000A0008>
@endverbatim


@subsection qview_poke Poke Command
The "Poke Obj/Addr..." command allows you to write data to the specified object or address in Target's RAM (**NOTE:** You can provide either the object name, which must be known by its object-dictionary, or numerical address, which **must** be a valid RAM address, or the Target might crash.)

@attention
The "Poke..." menu requires the "Current-Obj AP_OBJ" to be set in the @ref qview_curr, because this is the object within the Target which will be "poked". The "Poke..." menu is **inactive** (grayed-out) when the "Current-Obj AP_OBJ" is not specified.


@note
The Poke Command can be used to change any **writable** address, such as RAM, but also **peripheral registers** in your Target.


As shown in the screen shot below, the POKE command takes additionally the  offset into the object [bytes], the size of the item [8-bit, 16-bit, 32-bit], and the data to "poke", which can be either decimal or hexadecimal (`0x` prefix).

@image html qview_cmd_poke.gif "Poke Command Dialog Box"
@n

The Target responds with `Trg-Ack  QS_RX_POKE`:

@verbatim
           Trg-Ack  QS_RX_POKE
@endverbatim


@section qview_events Events Menu
The "Events" menu allows you to Publish, Post, or Dispatch an event to the Target. Additionally, you can also "Initialize" a state machine by triggering the top-most initial transition in it.

@attention
The "Post..." menu requires the "Current-Obj AO_OBJ" to be set in the @ref qview_curr, because this is the Ative Object within the Target which will be "posted". The "Dispatch..." and "Init SM..." menus require the "Current-Obj SM_OBJ" to be set in the @ref qview_curr, because this is the State Machine within the Target which will be "dispatched" or "initialized". These menus are **inactive** (grayed-out) when the expected "Current-Objects" are not specified.

@image html qview_evt_dlg.gif "Events Menu with Post-Event Dialog Box"

As shown in the screen-shot above, you define the custom event by providing the sig (signal), which can be either symbolic name (must correspond to the Signal Dictionary) or a numerical value.

The signal is followed by up to 9 optional event parameters par1..par9. Each parameter is specified as a pair of the size of the parameter [8-bit, 16-bit, 32-bit], and the value of the parameter, which can be either decimal or hexadecimal (`0x` prefix).

@attention
The parameters are sent using the **endianness** reported by the Target. Also, all the specified parameters are packed in the exact order without any "alignment". If the event structure is represented in the Target memory with some **padding**, you need to provide such padding explicitly (as one of the parameters).


@section qview_custom Custom Menu
This top-level menu is provided for your customization. It's intent is to let you add your own commands in your script.

@image html qview_cust.gif


@section qview_help Help Menu
This menu allows you to access the online Q-SPY help in HTML, and also allows you to open the "About" dialog box.

@image html qview_help.gif

@nav{qutest_script,qview_cust}
*/
/*###########################################################################*/
/**
@page qview_cust Customizing &amp; Extending QView&trade;

@tableofcontents
@nav{qview_ui,qwin}

QView&trade; has been specifically designed for extensibility, so that you can customize its behavior to your specific project. In fact, as mentioned in the section about @ref qview_run "running QView", the <span class="img file_py"><b>qview.py</b></span> script takes the `<cust-script>` @ref qview_command "command-line parameter", which is another Python script designed specifically to extend and customize the basic functionality. This section describes how to write this @ref qview_script "customization script", so that you can turn QView&trade; into a powerful remote **Human-Machine Interface** (HMI) for your embedded system.

@remark
You don't need to change the <span class="img file_py"><b>qview.py</b></span> script to customize and extend it for your project. The customization you make go into a separate script, which is specific to your project. That way, you can have many different customization scripts and you don't pollute (and possibly break) the original code.


@section qview_cust_menu Custom Menu
The simple way of customizing QView&trade; is to add **custom menus**.

@image html qview_cust.gif


@section qview_canvas Custom Canvas
The main part of the QView&trade; interface that you customize for your specific embedded system is the **custom Canvas**. The custom Canvas can show a complete custom Human-Machine Interface (HMI) to your embedded Target. The Canvas can display the changing status of the application and also it can provide **actuators**, like buttons, sliders, etc. to **interact** with the embedded Target. The following animation shows the custom Canvas for the DPP example (<span class="img file_py">dpp.py</span> script explained later). Please note that the button in the center of the screen allows you to interact with the Target by posting events to it. Please refer to this script code for the details of how various effects have been achieved.

@image html qview_canv_dpp.gif "Custom Canvas for the DPP Application"

@n
@note
QView&trade; GUI is based on the [<b>Tkinter</b>](https://docs.python.org/3/library/tkinter.html) and therefore it is highly recommended that you get familiar with this Python library. Specifically of interest for customizing QView&trade; is the [<b>Tkinter Canvas</b>](https://www.tutorialspoint.com/python/tk_canvas.htm).@n
@n
Many Python widget libraries (e.g. [tk_tools](https://github.com/slightlynybbled/tk_tools), etc.) are available to aid you in developing your custom canvas. With such widget libraries, you can display the data in an attractive form: as gauges, bars, graphs, and sliders. The attractiveness of the GUI is limited only by your creativity.


@section qview_script Customization Script
The easiest way to customize QView is to copy the provided example script (<span class="img file_py">dpp.py</span> located in <span class="img folder"><qpc|qpcpp>/examples/workstation/dpp/qview</span> folder), rename it, and add your own extensions. The explanation section following the listing clarifies the interesting lines of code (lines starting with `[xx]` labels).

@code{py}
[1]  class DPP:
[2]      def __init__(self):

             # request target reset on startup...
[3]          reset_target()

             # add commands to the Custom menu...
[4]          QView.custom_menu.add_command(label="Custom command",
                                           command=self.cust_command)

             # configure the custom QView.canvas...
[5]          QView.show_canvas() # make the canvas visible
[6]          QView.canvas.configure(width=400, height=260)

             # tuple of activity images (correspond to self._philo_state)
[7]          self._act_img = (
[8]              PhotoImage(file=HOME_DIR + "/img/thinking.gif"),
                 PhotoImage(file=HOME_DIR + "/img/hungry.gif"),
                 PhotoImage(file=HOME_DIR + "/img/eating.gif"),
             )
             # tuple of philo canvas images (correspond to self._philo_obj)
             self._philo_img = (\
                 QView.canvas.create_image(190,  57, image=self._act_img[0]),
                 QView.canvas.create_image(273, 100, image=self._act_img[0]),
                 QView.canvas.create_image(237, 185, image=self._act_img[0]),
                 QView.canvas.create_image(146, 185, image=self._act_img[0]),
                 QView.canvas.create_image(107, 100, image=self._act_img[0])
             )

             # button images for UP and DOWN
             self.img_UP  = PhotoImage(file=HOME_DIR + "/img/BTN_UP.gif")
             self.img_DWN = PhotoImage(file=HOME_DIR + "/img/BTN_DWN.gif")

             # images of a button for pause/serve
             self.btn = QView.canvas.create_image(200, 120, image=self.img_UP)
[9]          QView.canvas.tag_bind(self.btn, "<ButtonPress-1>", self.cust_pause)


         # on_reset() callback
[10]     def on_reset(self):
             # clear the lists
[11]         self._philo_obj   = [0, 0, 0, 0, 0]
             self._philo_state = [0, 0, 0]

         # on_run() callback
[20]     def on_run(self):
[21]         glb_filter("QS_USER_00")

             # NOTE: the names of objects for loc_filter() and current_obj()
             # must match the QS Object Dictionaries produced by the application.
[22]         current_obj(OBJ_AO, "Table_inst")
[23]         loc_filter(IDS_AO)

             # turn lists into tuples for better performance
[24]         self._philo_obj = tuple(self._philo_obj)
             self._philo_state = tuple(self._philo_state)


         # example of a custom command
[30]     def cust_command(self):
[31]         command(1, 12345)

         # example of a custom interaction with a canvas object (pause/serve)
[40]     def cust_pause(self, event):
[41]         if QView.canvas.itemcget(self.btn, "image") != str(self.img_UP):
[42]             QView.canvas.itemconfig(self.btn, image=self.img_UP)
[43]             post("SERVE_SIG")
[44]             QView.print_text("Table SERVING")
             else:
                 QView.canvas.itemconfig(self.btn, image=self.img_DWN)
                 post("PAUSE_SIG")
                 QView.print_text("Table PAUSED")

         # intercept the QS_USER_00 application-specific packet
         # this packet has the following structure (see bsp.c:displayPhilStat()):
         # record-ID, seq-num, Timestamp, format-byte, Philo-num,
         #    format-bye, Zero-terminated string (status)
[50]     def QS_USER_00(self, packet):
             # unpack: Timestamp->data[0], Philo-num->data[1], status->data[3]
[51]         data = qunpack("xxTxBxZ", packet)
             i = data[1]
             j = ("t", "h", "e").index(data[2][0]) # the first letter

             # animate the given philo image according to its activity
             QView.canvas.itemconfig(self._philo_img[i], image=self._act_img[j])

             # print a message to the text view
             QView.print_text("%010d Philo %1d is %s"%(data[0], i, data[2]))

     #=============================================================================
[60] QView.customize(DPP()) # set the QView customization

@endcode

@subsection qview_cust_init Initialization

<dl class="tag">
  <dt>1</dt><dd> Every QView&trade; customization consists of a Python __class__, which does not extend any other class and can be called with any name you see fit.
  </dd>
  <dt>2</dt><dd> The constructor of your customization class sets up the GUI and optionally resets the target.
  </dd>
  <dt>3</dt><dd> The reset_target() command allows you to remotely reset the embedded Target.
> **NOTE:** Normally, for an embedded application you would like to start with resetting the Target, to start clean with @ref qs_dict "QS dictionaries", etc. However, if you run your application on the **host** (e.g., `<qpc|qpcpp>/examples/workstation/dpp`), you typically don't want to reset the target. Instead, you simply launch the host executable *after* opening QView&trade;, so that it will "see" all the QS dictionaries, etc. This alternative is shown in the DPP example for the host located in `<qpc|qpcpp>/examples/workstation/dpp`).
  </dd>
  <dt>4</dt><dd> The @ref qview.QView.custom_menu "QView.custom_menu" object allows you to extend the @ref qview_custom "Custom Menu" with your own commands. Here, you just add the command "Custom command". Later you will write the function that handles this menu item.
> **NOTE:** The @ref qview.QView.custom_menu "QView.custom_menu" object uses the [Tkinter Menu interface](https://www.tutorialspoint.com/python/tk_menu.htm)
  </dd>
</dl>
<div style="clear:both;"></div>


@subsection qview_cust_canvas Setting Up the Canvas
The Custom Canvas is setup in the **constructor** of the customization clss `__init__(self)`) using the @ref qview.QView.canvas "QView.canvas" object:

<dl class="tag">
  <dt>5</dt><dd> The @ref qview.QView.show_canvas() "QView.show_canvas()" function lets you @ref  show the canvas from the beginning. This corresponds to setting the Canvas checkbox in the @ref qview_view.
  </dd>
  <dt>6</dt><dd> The @ref qview.QView.canvas "QView.canvas" object can be configured to the desired size using the standard tkinter functionality.
> **NOTE:** The @ref qview.QView.canvas "QView.canvas" object uses the [Tkinter Canvas interface](https://www.tutorialspoint.com/python/tk_canvas.htm)
  </dd>
  <dt>7-8</dt><dd> You need to organize the GUI elements for the canvas, so that they easily map to your specific customization. Here, the images representing the Dining Philosophers activities and Philosophers themselves sitting around the table are represented as [Python tuples](https://www.tutorialspoint.com/python/python_tuples.htm).
> **NOTE:** The proper design of the data structures for your application can vastly simplify the customization script. Please remember to take advantage of the rich Python data structures, such as lists, tuples, dictionaries and arrays.
  </dd>
  <dt>9</dt><dd> This line demonstrates how to provide a **keyboard binding** to a canvas element (the center button `self.btn` in this case).
  </dd>
</dl>
<div style="clear:both;"></div>


@subsection qview_cust_reset The on_reset() Callback
The main <span class="img file_py"><b>qview.py</b></span> script calls the on_reset() callback function in your customization script when it receives the @ref #QS_TARGET_INFO "reset packet" from the Target. This gives you an opportunity to clear your internal data structures to get them ready for new data coming from the Target (e.g. @ref qs_dict).

<dl class="tag">
  <dt>10</dt><dd> The @ref on_reset() callback must be member of the customization class (note the `self` parameter).
  </dd>
  <dt>11</dt><dd> Here, the callback clears the internal lists used by customization.
  </dd>
</dl>
<div style="clear:both;"></div>


@subsection qview_cust_run The on_run() Callback
The main <span class="img file_py"><b>qview.py</b></span> script calls the on_run() callback function in your customization script when it receives the @ref #QS_QF_RUN trace record from the Target. This record typically marks the end of the Target initialization and, specifically, the completion of the @qs_dict. This gives you an opportunity to set the @ref qs_filters, @ref qs_curr, using their **symbolic names**.

@note
The **symbolic names** inside the Target are known to QSPY only *after* the Target produces the @ref qs_dict.


<dl class="tag">
  <dt>20</dt><dd> The @ref on_run() callback must be member of the customization class (note the `self` parameter).
  </dd>
  <dt>21</dt><dd> Here, the callback sets the @ref qs_global "Global Filter" by means of the glb_filter() facility provided in the <span class="img file_py"><b>qview.py</b></span> script.
  </dd>
  <dt>22</dt><dd> Here, the callback sets the @ref qs_curr "Current Objects" by means of the current_obj() facility provided in the <span class="img file_py"><b>qview.py</b></span> script.
  </dd>
  <dt>23</dt><dd> Here, the callback sets the @ref qs_local "Local Filter" by means of the loc_filter() facility provided in the <span class="img file_py"><b>qview.py</b></span> script.
  </dd>
</dl>
<div style="clear:both;"></div>

@note
The glb_filter(), current_obj(), and loc_filter() facilities in QView&trade; are **identical** as in the @ref qutest "QUTest". This commonality between @ref qview "QView&trade;" and @ref qutest "QUTest&trade;" is intentional.


@subsection qview_cust_cmd Custom Commands
The Custom Command added either to the @ref qview.QView.custom_menu "QView.custom_menu" or attached to the Canvas elements need to be implemented as a member functions of the customization class:

<dl class="tag">
  <dt>30</dt><dd> The function name must match the `command=self.cust_command` parameter in the `menu.add_command()` (see step [4] of the script)
  </dd>
  <dt>31</dt><dd> Here, the function invokes the command() facility provided in the <span class="img file_py"><b>qview.py</b></span> script.
  </dd>
  <dt> </dt><dd>&nbsp;
  </dd>
  <dt>40</dt><dd> The function name must match the `...tag_bind(... self.cust_pause)` parameter (see step [9] of the script)
  </dd>
  <dt>41</dt><dd> Here, the function **checks the Canvas elements** (using the standard Tkinter functionality).
  </dd>
  <dt>42</dt><dd> Here, the function **configures the Canvas elements** (using the standard Tkinter functionality).
  </dd>
  <dt>43</dt><dd> Here, the function **posts an event** to the Target by means of the post() facility provided in the <span class="img file_py"><b>qview.py</b></span> script.
  </dd>
  <dt>43</dt><dd> Here, the function **prints text** to the @ref qview_ui "Text View" by means of the @ref qview.QView.print_text() "QView.print_text()" facility provided in the <span class="img file_py"><b>qview.py</b></span> script.
  </dd>
</dl>
<div style="clear:both;"></div>

@note
The command() and post() facilities in QView&trade; are **identical** as in the @ref qutest "QUTest". This commonality between @ref qview "QView&trade;" and @ref qutest "QUTest&trade;" is intentional.


@subsection qview_cust_handler Custom Packet Handlers
The most important feature of QView&trade; is that it can display the **live** status of the embedded system. QView&trade; achieves it by receiving the QS software tracing packets from the Target. Consequently, one of the most important activities of the customization script is to intercept and parse the incoming packets.

To this end, the <span class="img file_py"><b>qview.py</b></span> script provides special accumulations:

- the <span class="img file_py"><b>qview.py</b></span> script provides a **packet-specific callback** for every QS trace record from the Target. The name of the callback is identical to the enumerated names of the #QSpyRecords of the trace records. For example, the packet-handler for the QS trace record #QS_QEP_TRAN is named `QS_QEP_TRAN()`.

- the <span class="img file_py"><b>qview.py</b></span> script provides the qunpack() facility, specifically designed to parse and unpack the QS trace records.


<dl class="tag">
  <dt>50</dt><dd> The packet-handler name must match the enumeration #QSpyRecords. Here, the packet-handler is for the #QS_USER_00 trace record
  </dd>
  <dt>51</dt><dd> Here, the packet-handler calls the qunpack() facility to "unpack" the binary data form the received packet into the Python tuple `data`. Each element in this tuple corresponds to the explicitly specified format. For example, with the format "xxTxBxZ": the "T" format (timestamp) is unpacked into `data[0]`, the "B" format (byte) is unpacked into `data[1]`, and the "Z" format (zero-terminated ASCII string) is unpacked into `data[2]`. Subsequently, in the body of the function the `data[]` elements are used according to their meaning.
  </dd>
</dl>
<div style="clear:both;"></div>

@note
The qunpack() facility "understands" all formats supported by the Python `struct.unpack()` plus formats specific to the QP/Spy, such as: "T" for timestamp, "S" for event signal, ""


@subsection qview_cust_set Registering Customization in QView&trade;

<dl class="tag">
  <dt>60</dt><dd> Every QView&trade; customization script must end with a call to @ref qview.QView.customize() "QView.customize()" function, to which you need to pass the instance of your Customization class (here your `DPP` class).
  </dd>
</dl>
<div style="clear:both;"></div>


@subsection qview_pre App-Specific Vs. Predefined Trace Records
The customization script discussed in the previous section was based on the @ref qs_app "application-specific trace record" (`QS_USER_00`), which was specifically produced by the DPP application. This trace record delivered the information abou the changing status of the Dining Philosophers, which allowed the customization script to animate the Philosopher images on the custom canvas.

However, it is also possible to use a different strategy based on the @ref qs_pre "predefined QS trace records". The advantage is that **no additional instrumentation** is needed in the application, because the information is already produced by the framework. All you need to do is to enable (in the global filter) the appropriate QS trace record.

This alternative strategy is illustrated in the <span class="img file_py">dpp1.py</span> script (located in the same directory as the <span class="img file_py">dpp.py</span> script discussed earlier). The <span class="img file_py">dpp1.py</span> script is based on the predefined QS record #QS_QEP_TRAN, which provides the information about the **state changes** in the Philo objects in the application.

The most tricky part in this approach is to correctly unpack the predefined record. And here, the biggest challenge is to translate the binary addresses of the objects to their **symbolic names**. For that, the <span class="img file_py">dpp1.py</span> script intercepts the @ref qs_dict "QS dictionary" records #QS_OBJ_DICT and #QS_FUN_DICT, from which the script retrieves the binary addresses of the specific objects. Below are the relevant snippets from the <span class="img file_py">dpp.py</span> script. Please note the use of Python lists, tuples, and dictionaries to organize the data for easy access by the index number of the Philo objects or by the state name.

@code{py}
class DPP:
    . . .
    # intercept the QS_OBJ_DICT stadard packet
    # this packet has the following structure:
    # record-ID, seq-num, Object-ptr, Zero-terminated string
    def QS_OBJ_DICT(self, packet):
        data = qunpack("xxOZ", packet)
        try:
            # NOTE: the names of objects must match the QS Object Dictionaries
            # produced by the application.
            i = ("Philo_inst[0]",
                 "Philo_inst[1]",
                 "Philo_inst[2]",
                 "Philo_inst[3]",
                 "Philo_inst[4]").index(data[1])
            self._philo_obj[i] = data[0]
        except:
            pass # dictionary for a different object

    # intercept the QS_FUN_DICT stadard packet
    # this packet has the following structure:
    # record-ID, seq-num, Function-ptr, Zero-terminated string
    def QS_FUN_DICT(self, packet):
        data = qunpack("xxFZ", packet)
        try:
            # NOTE: the names of states must match the QS Object Dictionaries
            # produced by the application.
            j = ("Philo_thinking",
                 "Philo_hungry",
                 "Philo_eating").index(data[1])
            self._philo_state[j] = data[0]
        except:
            pass # dictionary for a different state

    # intercept the QS_QEP_TRAN stadard packet
    # this packet has the following structure:
    # record-ID, seq-num, Timestamp, Signal, Object-ptr,
    #     Function-ptr (source state), Function-ptr (new active state)
    def QS_QEP_TRAN(self, packet):
        data = qunpack("xxTSOFF", packet)
        try:
            i = self._philo_obj.index(data[2])
            j = self._philo_state.index(data[4])

            # animate the given philo image according to its activity
            QView.canvas.itemconfig(self._philo_img[i],
                                   image=self._act_img[j])
            # print a message to the text view
            QView.print_text("%010d Philo %d is %s"\
                    %(data[0], i, ("thinking", "hungry", "eating")[j]))
        except:
            pass # state-entry in a different object
    . . .
@endcode

@n
@note
The presented strategy of intercepting the @ref qs_dict "QS dictionary" records #QS_OBJ_DICT and #QS_FUN_DICT is quite generic and can be easily adapted in your own customization scripts.


@subsection qview_dsl-commands QView Script Commands
Here is the summary of commands that you can use in the QView scripts:

- reset_target()
- command()
- peek()
- poke()
- tick()
- glb_filter()
- loc_filter()
- ao_filter()
- current_obj()
- query_curr()
- post()
- publish()
- init()
- dispatch()
- qunpack()

@nav{qutest,qwin}
*/

